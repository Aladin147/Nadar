{"version":3,"sources":["../../core/ocrCore.ts"],"sourcesContent":["// Core business logic for OCR endpoint - runtime agnostic\n\nimport { \n  Result, \n  ProviderError,\n  AssistDeps,\n  TelemetryData\n} from '../types/api';\n\nexport interface OCRRequest {\n  sessionId: string;\n  image?: Uint8Array;\n  imageRef?: string;\n  full?: boolean;\n  language?: 'darija' | 'ar' | 'en';\n}\n\nexport interface OCRResponse {\n  text: string;\n  timing: {\n    processing_ms: number;\n    total_ms: number;\n  };\n}\n\nfunction createOCRPrompt(language: string, full: boolean): string {\n  const langDir = language === 'ar' ? 'اكتب بالعربية الفصحى' : \n                  language === 'darija' ? 'اكتب بالدارجة المغربية' : \n                  'Write in English';\n\n  if (full) {\n    return `${langDir} Extract ALL text from this image. Include:\n- All readable text, signs, labels, captions\n- Text in any language or script\n- Numbers, dates, times\n- Menu items, prices, addresses\n- Any other textual content\n\nReturn only the extracted text, preserving the original structure and formatting where possible.`;\n  } else {\n    return `${langDir} Extract the main text content from this image. Focus on:\n- Primary text, headlines, main content\n- Important signs or labels\n- Key information that would be most relevant\n\nReturn only the extracted text in a clear, readable format.`;\n  }\n}\n\n// Core OCR handler - pure business logic\nexport async function handleOCR(\n  request: OCRRequest,\n  deps: AssistDeps\n): Promise<Result<OCRResponse>> {\n  const startTime = deps.now();\n  \n  try {\n    // Resolve image\n    let image: Uint8Array;\n    if (request.image) {\n      image = request.image;\n    } else if (request.imageRef) {\n      const cachedImage = await deps.imageStore.get(request.imageRef);\n      if (!cachedImage) {\n        const error = {\n          message: `No cached image found for imageRef: ${request.imageRef}`,\n          err_code: 'IMAGE_NOT_FOUND'\n        };\n        \n        // Log error telemetry\n        deps.telemetry.log({\n          ts: new Date().toISOString(),\n          mode: 'ocr',\n          engine: 'gemini',\n          route_path: '/ocr',\n          image_bytes: 0,\n          audio_bytes_in: 0,\n          total_ms: deps.now() - startTime,\n          model_ms: 0,\n          tts_ms: 0,\n          chars_out: 0,\n          ok: false,\n          err_code: error.err_code,\n          request_id: request.sessionId\n        });\n        \n        return { ok: false, error };\n      }\n      image = cachedImage;\n    } else {\n      const error = {\n        message: 'No valid image provided',\n        err_code: 'INVALID_IMAGE'\n      };\n      \n      // Log error telemetry\n      deps.telemetry.log({\n        ts: new Date().toISOString(),\n        mode: 'ocr',\n        engine: 'gemini',\n        route_path: '/ocr',\n        image_bytes: 0,\n        audio_bytes_in: 0,\n        total_ms: deps.now() - startTime,\n        model_ms: 0,\n        tts_ms: 0,\n        chars_out: 0,\n        ok: false,\n        err_code: error.err_code,\n        request_id: request.sessionId\n      });\n      \n      return { ok: false, error };\n    }\n    \n    // Generate OCR response\n    const processingStart = deps.now();\n    const language = request.language || 'darija';\n    const prompt = createOCRPrompt(language, request.full || false);\n    \n    const responseResult = await deps.providers.generateResponse(\n      image,\n      'image/jpeg',\n      prompt\n    );\n\n    if (!responseResult.ok) {\n      const errorResult = responseResult as { ok: false; error: ProviderError };\n      return { ok: false, error: errorResult.error };\n    }\n    \n    const processingTime = deps.now() - processingStart;\n    const totalTime = deps.now() - startTime;\n    const extractedText = responseResult.data.trim();\n    \n    // Log successful telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'ocr',\n      engine: 'gemini',\n      route_path: '/ocr',\n      image_bytes: image.length,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: processingTime,\n      tts_ms: 0,\n      chars_out: extractedText.length,\n      ok: true,\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: true,\n      data: {\n        text: extractedText,\n        timing: {\n          processing_ms: processingTime,\n          total_ms: totalTime\n        }\n      }\n    };\n    \n  } catch (error: any) {\n    const totalTime = deps.now() - startTime;\n    \n    // Log error telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'ocr',\n      engine: 'gemini',\n      route_path: '/ocr',\n      image_bytes: 0,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: 0,\n      tts_ms: 0,\n      chars_out: 0,\n      ok: false,\n      err_code: error.err_code || 'UNKNOWN',\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: false,\n      error: {\n        message: error.message || 'Internal server error',\n        err_code: error.err_code || 'UNKNOWN',\n        details: error.details\n      }\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA,SAAS,gBAAgB,UAAkB,MAAuB;AAChE,QAAM,UAAU,aAAa,OAAO,mHACpB,aAAa,WAAW,+HACxB;AAEhB,MAAI,MAAM;AACR,WAAO,GAAG,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnB,OAAO;AACL,WAAO,GAAG,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnB;AACF;AAGA,eAAsB,UACpB,SACA,MAC8B;AAC9B,QAAM,YAAY,KAAK,IAAI;AAE3B,MAAI;AAEF,QAAI;AACJ,QAAI,QAAQ,OAAO;AACjB,cAAQ,QAAQ;AAAA,IAClB,WAAW,QAAQ,UAAU;AAC3B,YAAM,cAAc,MAAM,KAAK,WAAW,IAAI,QAAQ,QAAQ;AAC9D,UAAI,CAAC,aAAa;AAChB,cAAM,QAAQ;AAAA,UACZ,SAAS,uCAAuC,QAAQ,QAAQ;AAAA,UAChE,UAAU;AAAA,QACZ;AAGA,aAAK,UAAU,IAAI;AAAA,UACjB,KAAI,oBAAI,KAAK,GAAE,YAAY;AAAA,UAC3B,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,gBAAgB;AAAA,UAChB,UAAU,KAAK,IAAI,IAAI;AAAA,UACvB,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,WAAW;AAAA,UACX,IAAI;AAAA,UACJ,UAAU,MAAM;AAAA,UAChB,YAAY,QAAQ;AAAA,QACtB,CAAC;AAED,eAAO,EAAE,IAAI,OAAO,MAAM;AAAA,MAC5B;AACA,cAAQ;AAAA,IACV,OAAO;AACL,YAAM,QAAQ;AAAA,QACZ,SAAS;AAAA,QACT,UAAU;AAAA,MACZ;AAGA,WAAK,UAAU,IAAI;AAAA,QACjB,KAAI,oBAAI,KAAK,GAAE,YAAY;AAAA,QAC3B,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,gBAAgB;AAAA,QAChB,UAAU,KAAK,IAAI,IAAI;AAAA,QACvB,UAAU;AAAA,QACV,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,IAAI;AAAA,QACJ,UAAU,MAAM;AAAA,QAChB,YAAY,QAAQ;AAAA,MACtB,CAAC;AAED,aAAO,EAAE,IAAI,OAAO,MAAM;AAAA,IAC5B;AAGA,UAAM,kBAAkB,KAAK,IAAI;AACjC,UAAM,WAAW,QAAQ,YAAY;AACrC,UAAM,SAAS,gBAAgB,UAAU,QAAQ,QAAQ,KAAK;AAE9D,UAAM,iBAAiB,MAAM,KAAK,UAAU;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,CAAC,eAAe,IAAI;AACtB,YAAM,cAAc;AACpB,aAAO,EAAE,IAAI,OAAO,OAAO,YAAY,MAAM;AAAA,IAC/C;AAEA,UAAM,iBAAiB,KAAK,IAAI,IAAI;AACpC,UAAM,YAAY,KAAK,IAAI,IAAI;AAC/B,UAAM,gBAAgB,eAAe,KAAK,KAAK;AAG/C,SAAK,UAAU,IAAI;AAAA,MACjB,KAAI,oBAAI,KAAK,GAAE,YAAY;AAAA,MAC3B,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,YAAY;AAAA,MACZ,aAAa,MAAM;AAAA,MACnB,gBAAgB;AAAA,MAChB,UAAU;AAAA,MACV,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,WAAW,cAAc;AAAA,MACzB,IAAI;AAAA,MACJ,YAAY,QAAQ;AAAA,IACtB,CAAC;AAED,WAAO;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,QAAQ;AAAA,UACN,eAAe;AAAA,UACf,UAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AAAA,EAEF,SAAS,OAAY;AACnB,UAAM,YAAY,KAAK,IAAI,IAAI;AAG/B,SAAK,UAAU,IAAI;AAAA,MACjB,KAAI,oBAAI,KAAK,GAAE,YAAY;AAAA,MAC3B,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,UAAU;AAAA,MACV,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,IAAI;AAAA,MACJ,UAAU,MAAM,YAAY;AAAA,MAC5B,YAAY,QAAQ;AAAA,IACtB,CAAC;AAED,WAAO;AAAA,MACL,IAAI;AAAA,MACJ,OAAO;AAAA,QACL,SAAS,MAAM,WAAW;AAAA,QAC1B,UAAU,MAAM,YAAY;AAAA,QAC5B,SAAS,MAAM;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACF;","names":[]}