{"version":3,"sources":["../../providers/geminiProvider.ts","../../utils/performance.ts"],"sourcesContent":["// Gemini AI provider implementation with performance optimizations\n\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { AIProvider, Result, ImageSignals, ProviderError } from '../types/api';\nimport {\n  PerformanceConfig,\n  DEFAULT_PERFORMANCE_CONFIG,\n  optimizeImageForAI,\n  createOptimizedPrompt,\n  globalResponseCache,\n  globalPerformanceMonitor,\n  simpleHash\n} from '../utils/performance';\n\nexport class GeminiProvider implements AIProvider {\n  private genAI: GoogleGenerativeAI;\n  private config: PerformanceConfig;\n\n  constructor(apiKey: string, config?: Partial<PerformanceConfig>) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.config = { ...DEFAULT_PERFORMANCE_CONFIG, ...config };\n  }\n\n  async inspectImage(image: Uint8Array, mimeType: string): Promise<Result<ImageSignals>> {\n    const startTime = Date.now();\n\n    try {\n      // Use fastest model for inspection\n      const model = this.genAI.getGenerativeModel({ model: this.config.fastModel });\n      \n      const prompt = `Analyze this image quickly and return ONLY a JSON object with these exact fields:\n{\n  \"has_text\": boolean (true if any readable text is visible),\n  \"hazards\": string[] (list of safety hazards like \"moving vehicle\", \"stairs\", \"obstacle\", max 3),\n  \"people_count\": number (count of people visible, 0-10+),\n  \"lighting_ok\": boolean (true if lighting is adequate for clear vision),\n  \"confidence\": number (0.0-1.0, overall confidence in analysis)\n}\n\nBe concise and accurate. Return only valid JSON.`;\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        prompt,\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        }\n      ]);\n\n      const responseText = result.response.text().trim();\n      \n      try {\n        const signals = JSON.parse(responseText);\n\n        const responseTime = Date.now() - startTime;\n        globalPerformanceMonitor.recordRequest(responseTime, false, false);\n        console.log(`⚡ Fast inspection completed in ${responseTime}ms`);\n\n        return {\n          ok: true,\n          data: {\n            has_text: Boolean(signals.has_text),\n            hazards: Array.isArray(signals.hazards) ? signals.hazards.slice(0, 3).map(String) : [],\n            people_count: Math.max(0, Math.min(10, Number(signals.people_count) || 0)),\n            lighting_ok: Boolean(signals.lighting_ok),\n            confidence: Math.max(0, Math.min(1, Number(signals.confidence) || 0))\n          }\n        };\n      } catch (parseError) {\n        console.warn('Failed to parse image inspector JSON:', responseText);\n        return {\n          ok: true,\n          data: {\n            has_text: responseText.toLowerCase().includes('text'),\n            hazards: [],\n            people_count: 0,\n            lighting_ok: true,\n            confidence: 0.5\n          }\n        };\n      }\n    } catch (error: any) {\n      console.error('Image inspection failed:', error);\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Image inspection failed',\n          err_code: 'INSPECTION_ERROR',\n          details: error.toString()\n        }\n      };\n    }\n  }\n\n  async generateResponse(image: Uint8Array, mimeType: string, prompt: string): Promise<Result<string>> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const imageHash = simpleHash(image);\n      const cacheKey = globalResponseCache.generateKey(imageHash, 'darija', prompt.includes('question') ? 'qa' : undefined);\n\n      if (this.config.enableResponseCache) {\n        const cachedResponse = globalResponseCache.get(cacheKey);\n        if (cachedResponse) {\n          const responseTime = Date.now() - startTime;\n          globalPerformanceMonitor.recordRequest(responseTime, true, false);\n          console.log(`⚡ Cache hit! Response served in ${responseTime}ms`);\n          return { ok: true, data: cachedResponse };\n        }\n      }\n\n      // Use quality model for main response\n      const model = this.genAI.getGenerativeModel({ model: this.config.qualityModel });\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        },\n        { text: prompt }\n      ]);\n\n      const response = await result.response;\n      const text = response.text();\n\n      // Cache the response\n      if (this.config.enableResponseCache) {\n        globalResponseCache.set(cacheKey, text);\n      }\n\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, false);\n      console.log(`⚡ Response generated in ${responseTime}ms`);\n\n      return {\n        ok: true,\n        data: text\n      };\n      \n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, true);\n\n      console.error('Response generation failed:', error);\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Response generation failed',\n          err_code: 'GENERATION_ERROR',\n          details: error.toString()\n        }\n      };\n    }\n  }\n}\n","// Performance optimization utilities for Nadar shared core\n\nimport { ImageSignals } from '../types/api';\n\n// Performance configuration\nexport interface PerformanceConfig {\n  // Gemini model selection for speed vs quality tradeoff\n  fastModel: string;      // For inspection (speed priority)\n  qualityModel: string;   // For main response (quality priority)\n  \n  // Prompt optimization\n  maxPromptLength: number;\n  useCompactPrompts: boolean;\n  \n  // Image optimization\n  maxImageSize: number;   // Max bytes before compression\n  compressionQuality: number; // 0.1-1.0\n  \n  // Parallel processing\n  enableParallelInspection: boolean;\n  \n  // Caching\n  enableResponseCache: boolean;\n  cacheKeyFields: string[];\n}\n\n// Default performance configuration optimized for 3-4s target\nexport const DEFAULT_PERFORMANCE_CONFIG: PerformanceConfig = {\n  fastModel: 'gemini-2.5-flash-lite',     // Fastest for inspection\n  qualityModel: 'gemini-2.5-flash',       // Balanced for main response\n  maxPromptLength: 1000,                  // Shorter prompts = faster\n  useCompactPrompts: true,                // Use optimized prompt templates\n  maxImageSize: 1024 * 1024,             // 1MB max before compression\n  compressionQuality: 0.8,                // Good quality/speed balance\n  enableParallelInspection: false,        // Keep sequential for now\n  enableResponseCache: true,              // Cache similar requests\n  cacheKeyFields: ['image_hash', 'language', 'question_type']\n};\n\n// Image optimization utilities\nexport function optimizeImageForAI(imageBuffer: Uint8Array, config: PerformanceConfig): Uint8Array {\n  // If image is already small enough, return as-is\n  if (imageBuffer.length <= config.maxImageSize) {\n    return imageBuffer;\n  }\n  \n  // For now, return original - would implement compression here\n  // TODO: Implement actual image compression using sharp or similar\n  console.log(`⚡ Image size ${imageBuffer.length} bytes exceeds ${config.maxImageSize}, compression needed`);\n  return imageBuffer;\n}\n\n// Prompt optimization utilities\nexport function createOptimizedPrompt(\n  basePrompt: string, \n  signals: ImageSignals, \n  config: PerformanceConfig\n): string {\n  if (!config.useCompactPrompts) {\n    return basePrompt;\n  }\n  \n  // Create more focused prompts based on signals\n  let optimizedPrompt = basePrompt;\n  \n  // If no text detected, skip text-related instructions\n  if (!signals.has_text) {\n    optimizedPrompt = optimizedPrompt.replace(/text|reading|signs|labels/gi, '');\n  }\n  \n  // If no people detected, skip people-related instructions\n  if (signals.people_count === 0) {\n    optimizedPrompt = optimizedPrompt.replace(/people|person|individuals/gi, '');\n  }\n  \n  // Truncate if too long\n  if (optimizedPrompt.length > config.maxPromptLength) {\n    optimizedPrompt = optimizedPrompt.substring(0, config.maxPromptLength) + '...';\n  }\n  \n  return optimizedPrompt;\n}\n\n// Response caching utilities\nexport interface CacheEntry {\n  response: string;\n  timestamp: number;\n  ttl: number; // Time to live in milliseconds\n}\n\nexport class ResponseCache {\n  private cache = new Map<string, CacheEntry>();\n  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes\n  \n  generateKey(imageHash: string, language: string, question?: string): string {\n    const questionType = question ? 'qa' : 'describe';\n    return `${imageHash}-${language}-${questionType}`;\n  }\n  \n  get(key: string): string | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    \n    // Check if expired\n    if (Date.now() > entry.timestamp + entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.response;\n  }\n  \n  set(key: string, response: string, ttl?: number): void {\n    this.cache.set(key, {\n      response,\n      timestamp: Date.now(),\n      ttl: ttl || this.defaultTTL\n    });\n  }\n  \n  clear(): void {\n    this.cache.clear();\n  }\n  \n  // Cleanup expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now > entry.timestamp + entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\n// Global cache instance\nexport const globalResponseCache = new ResponseCache();\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  totalRequests: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  cacheHitRate: number;\n  errorRate: number;\n  lastUpdated: number;\n}\n\nexport class PerformanceMonitor {\n  private metrics: number[] = [];\n  private cacheHits = 0;\n  private cacheMisses = 0;\n  private errors = 0;\n  private readonly maxSamples = 1000;\n  \n  recordRequest(responseTimeMs: number, wasCacheHit: boolean, wasError: boolean): void {\n    // Record response time\n    this.metrics.push(responseTimeMs);\n    if (this.metrics.length > this.maxSamples) {\n      this.metrics.shift(); // Remove oldest\n    }\n    \n    // Record cache performance\n    if (wasCacheHit) {\n      this.cacheHits++;\n    } else {\n      this.cacheMisses++;\n    }\n    \n    // Record errors\n    if (wasError) {\n      this.errors++;\n    }\n  }\n  \n  getMetrics(): PerformanceMetrics {\n    if (this.metrics.length === 0) {\n      return {\n        totalRequests: 0,\n        averageResponseTime: 0,\n        p95ResponseTime: 0,\n        cacheHitRate: 0,\n        errorRate: 0,\n        lastUpdated: Date.now()\n      };\n    }\n    \n    const sorted = [...this.metrics].sort((a, b) => a - b);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    const totalCacheRequests = this.cacheHits + this.cacheMisses;\n    const totalRequests = this.metrics.length;\n    \n    return {\n      totalRequests,\n      averageResponseTime: this.metrics.reduce((a, b) => a + b, 0) / this.metrics.length,\n      p95ResponseTime: sorted[p95Index] || 0,\n      cacheHitRate: totalCacheRequests > 0 ? this.cacheHits / totalCacheRequests : 0,\n      errorRate: totalRequests > 0 ? this.errors / totalRequests : 0,\n      lastUpdated: Date.now()\n    };\n  }\n  \n  reset(): void {\n    this.metrics = [];\n    this.cacheHits = 0;\n    this.cacheMisses = 0;\n    this.errors = 0;\n  }\n}\n\n// Global performance monitor\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n\n// Simple hash function for cache keys\nexport function simpleHash(data: Uint8Array): string {\n  let hash = 0;\n  for (let i = 0; i < Math.min(data.length, 1000); i++) { // Sample first 1000 bytes\n    hash = ((hash << 5) - hash + data[i]) & 0xffffffff;\n  }\n  return hash.toString(36);\n}\n"],"mappings":"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","names":["responseTime"]}