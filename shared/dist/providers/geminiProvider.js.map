{"version":3,"sources":["../../providers/geminiProvider.ts","../../utils/performance.ts","../../utils/reliability.ts"],"sourcesContent":["// Gemini AI provider implementation with performance optimizations\n\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { AIProvider, Result, ImageSignals, ProviderError } from '../types/api';\nimport {\n  PerformanceConfig,\n  DEFAULT_PERFORMANCE_CONFIG,\n  optimizeImageForAI,\n  createOptimizedPrompt,\n  globalResponseCache,\n  globalPerformanceMonitor,\n  simpleHash\n} from '../utils/performance';\nimport {\n  withRetry,\n  geminiCircuitBreaker,\n  DEFAULT_RETRY_CONFIG,\n  RetryConfig,\n  checkServiceHealth,\n  HealthStatus\n} from '../utils/reliability';\n\nexport class GeminiProvider implements AIProvider {\n  private genAI: GoogleGenerativeAI;\n  private config: PerformanceConfig;\n  private retryConfig: RetryConfig;\n\n  constructor(\n    apiKey: string,\n    config?: Partial<PerformanceConfig>,\n    retryConfig?: Partial<RetryConfig>\n  ) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.config = { ...DEFAULT_PERFORMANCE_CONFIG, ...config };\n    this.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n  }\n\n  async inspectImage(image: Uint8Array, mimeType: string): Promise<Result<ImageSignals>> {\n    // Wrap with circuit breaker and retry logic\n    return await geminiCircuitBreaker.execute(async () => {\n      return await withRetry(async () => {\n        return await this.performInspection(image, mimeType);\n      }, this.retryConfig, 'Gemini Image Inspection');\n    });\n  }\n\n  private async performInspection(image: Uint8Array, mimeType: string): Promise<Result<ImageSignals>> {\n    const startTime = Date.now();\n\n    try {\n      // Use fastest model for inspection\n      const model = this.genAI.getGenerativeModel({ model: this.config.fastModel });\n      \n      const prompt = `Analyze this image quickly and return ONLY a JSON object with these exact fields:\n{\n  \"has_text\": boolean (true if any readable text is visible),\n  \"hazards\": string[] (list of safety hazards like \"moving vehicle\", \"stairs\", \"obstacle\", max 3),\n  \"people_count\": number (count of people visible, 0-10+),\n  \"lighting_ok\": boolean (true if lighting is adequate for clear vision),\n  \"confidence\": number (0.0-1.0, overall confidence in analysis)\n}\n\nBe concise and accurate. Return only valid JSON.`;\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        prompt,\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        }\n      ]);\n\n      const responseText = result.response.text().trim();\n      \n      try {\n        const signals = JSON.parse(responseText);\n\n        const responseTime = Date.now() - startTime;\n        globalPerformanceMonitor.recordRequest(responseTime, false, false);\n        console.log(`⚡ Fast inspection completed in ${responseTime}ms`);\n\n        return {\n          ok: true,\n          data: {\n            has_text: Boolean(signals.has_text),\n            hazards: Array.isArray(signals.hazards) ? signals.hazards.slice(0, 3).map(String) : [],\n            people_count: Math.max(0, Math.min(10, Number(signals.people_count) || 0)),\n            lighting_ok: Boolean(signals.lighting_ok),\n            confidence: Math.max(0, Math.min(1, Number(signals.confidence) || 0))\n          }\n        };\n      } catch (parseError) {\n        console.warn('Failed to parse image inspector JSON:', responseText);\n        return {\n          ok: true,\n          data: {\n            has_text: responseText.toLowerCase().includes('text'),\n            hazards: [],\n            people_count: 0,\n            lighting_ok: true,\n            confidence: 0.5\n          }\n        };\n      }\n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, true);\n\n      console.error('Image inspection failed:', error);\n\n      // Map specific error types for better retry logic\n      let errorCode = 'INSPECTION_ERROR';\n      if (error.message?.includes('quota') || error.message?.includes('rate limit')) {\n        errorCode = 'RATE_LIMIT';\n      } else if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {\n        errorCode = 'TIMEOUT';\n      } else if (error.message?.includes('network') || error.code === 'ENOTFOUND') {\n        errorCode = 'NETWORK_ERROR';\n      } else if (error.status >= 500) {\n        errorCode = 'SERVICE_UNAVAILABLE';\n      }\n\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Image inspection failed',\n          err_code: errorCode,\n          details: error.toString()\n        }\n      };\n    }\n  }\n\n  async generateResponse(image: Uint8Array, mimeType: string, prompt: string): Promise<Result<string>> {\n    // Wrap with circuit breaker and retry logic\n    return await geminiCircuitBreaker.execute(async () => {\n      return await withRetry(async () => {\n        return await this.performGeneration(image, mimeType, prompt);\n      }, this.retryConfig, 'Gemini Response Generation');\n    });\n  }\n\n  private async performGeneration(image: Uint8Array, mimeType: string, prompt: string): Promise<Result<string>> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const imageHash = simpleHash(image);\n      const cacheKey = globalResponseCache.generateKey(imageHash, 'darija', prompt.includes('question') ? 'qa' : undefined);\n\n      if (this.config.enableResponseCache) {\n        const cachedResponse = globalResponseCache.get(cacheKey);\n        if (cachedResponse) {\n          const responseTime = Date.now() - startTime;\n          globalPerformanceMonitor.recordRequest(responseTime, true, false);\n          console.log(`⚡ Cache hit! Response served in ${responseTime}ms`);\n          return { ok: true, data: cachedResponse };\n        }\n      }\n\n      // Use quality model for main response\n      const model = this.genAI.getGenerativeModel({ model: this.config.qualityModel });\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        },\n        { text: prompt }\n      ]);\n\n      const response = await result.response;\n      const text = response.text();\n\n      // Cache the response\n      if (this.config.enableResponseCache) {\n        globalResponseCache.set(cacheKey, text);\n      }\n\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, false);\n      console.log(`⚡ Response generated in ${responseTime}ms`);\n\n      return {\n        ok: true,\n        data: text\n      };\n      \n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, true);\n\n      console.error('Response generation failed:', error);\n\n      // Map specific error types for better retry logic\n      let errorCode = 'GENERATION_ERROR';\n      if (error.message?.includes('quota') || error.message?.includes('rate limit')) {\n        errorCode = 'RATE_LIMIT';\n      } else if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {\n        errorCode = 'TIMEOUT';\n      } else if (error.message?.includes('network') || error.code === 'ENOTFOUND') {\n        errorCode = 'NETWORK_ERROR';\n      } else if (error.status >= 500) {\n        errorCode = 'SERVICE_UNAVAILABLE';\n      } else if (error.message?.includes('API key')) {\n        errorCode = 'MISSING_API_KEY';\n      }\n\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Response generation failed',\n          err_code: errorCode,\n          details: error.toString()\n        }\n      };\n    }\n  }\n\n  // Health check method\n  async checkHealth(): Promise<HealthStatus> {\n    return await checkServiceHealth(\n      'Gemini',\n      async () => {\n        try {\n          // Simple health check with minimal image\n          const testImage = new Uint8Array([137, 80, 78, 71]); // PNG header\n          const result = await this.performInspection(testImage, 'image/png');\n          // Even if it fails due to invalid image, if we get a response, service is up\n          return true;\n        } catch (error) {\n          return false;\n        }\n      },\n      geminiCircuitBreaker\n    );\n  }\n\n  // Get circuit breaker status\n  getCircuitBreakerStatus() {\n    return geminiCircuitBreaker.getState();\n  }\n\n  // Reset circuit breaker (for admin/debugging)\n  resetCircuitBreaker() {\n    geminiCircuitBreaker.reset();\n  }\n}\n","// Performance optimization utilities for Nadar shared core\n\nimport { ImageSignals } from '../types/api';\n\n// Performance configuration\nexport interface PerformanceConfig {\n  // Gemini model selection for speed vs quality tradeoff\n  fastModel: string;      // For inspection (speed priority)\n  qualityModel: string;   // For main response (quality priority)\n  \n  // Prompt optimization\n  maxPromptLength: number;\n  useCompactPrompts: boolean;\n  \n  // Image optimization\n  maxImageSize: number;   // Max bytes before compression\n  compressionQuality: number; // 0.1-1.0\n  \n  // Parallel processing\n  enableParallelInspection: boolean;\n  \n  // Caching\n  enableResponseCache: boolean;\n  cacheKeyFields: string[];\n}\n\n// Default performance configuration optimized for 3-4s target\nexport const DEFAULT_PERFORMANCE_CONFIG: PerformanceConfig = {\n  fastModel: 'gemini-2.5-flash-lite',     // Fastest for inspection\n  qualityModel: 'gemini-2.5-flash',       // Balanced for main response\n  maxPromptLength: 1000,                  // Shorter prompts = faster\n  useCompactPrompts: true,                // Use optimized prompt templates\n  maxImageSize: 1024 * 1024,             // 1MB max before compression\n  compressionQuality: 0.8,                // Good quality/speed balance\n  enableParallelInspection: false,        // Keep sequential for now\n  enableResponseCache: true,              // Cache similar requests\n  cacheKeyFields: ['image_hash', 'language', 'question_type']\n};\n\n// Image optimization utilities\nexport function optimizeImageForAI(imageBuffer: Uint8Array, config: PerformanceConfig): Uint8Array {\n  // If image is already small enough, return as-is\n  if (imageBuffer.length <= config.maxImageSize) {\n    return imageBuffer;\n  }\n  \n  // For now, return original - would implement compression here\n  // TODO: Implement actual image compression using sharp or similar\n  console.log(`⚡ Image size ${imageBuffer.length} bytes exceeds ${config.maxImageSize}, compression needed`);\n  return imageBuffer;\n}\n\n// Prompt optimization utilities\nexport function createOptimizedPrompt(\n  basePrompt: string, \n  signals: ImageSignals, \n  config: PerformanceConfig\n): string {\n  if (!config.useCompactPrompts) {\n    return basePrompt;\n  }\n  \n  // Create more focused prompts based on signals\n  let optimizedPrompt = basePrompt;\n  \n  // If no text detected, skip text-related instructions\n  if (!signals.has_text) {\n    optimizedPrompt = optimizedPrompt.replace(/text|reading|signs|labels/gi, '');\n  }\n  \n  // If no people detected, skip people-related instructions\n  if (signals.people_count === 0) {\n    optimizedPrompt = optimizedPrompt.replace(/people|person|individuals/gi, '');\n  }\n  \n  // Truncate if too long\n  if (optimizedPrompt.length > config.maxPromptLength) {\n    optimizedPrompt = optimizedPrompt.substring(0, config.maxPromptLength) + '...';\n  }\n  \n  return optimizedPrompt;\n}\n\n// Response caching utilities\nexport interface CacheEntry {\n  response: string;\n  timestamp: number;\n  ttl: number; // Time to live in milliseconds\n}\n\nexport class ResponseCache {\n  private cache = new Map<string, CacheEntry>();\n  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes\n  \n  generateKey(imageHash: string, language: string, question?: string): string {\n    const questionType = question ? 'qa' : 'describe';\n    return `${imageHash}-${language}-${questionType}`;\n  }\n  \n  get(key: string): string | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    \n    // Check if expired\n    if (Date.now() > entry.timestamp + entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.response;\n  }\n  \n  set(key: string, response: string, ttl?: number): void {\n    this.cache.set(key, {\n      response,\n      timestamp: Date.now(),\n      ttl: ttl || this.defaultTTL\n    });\n  }\n  \n  clear(): void {\n    this.cache.clear();\n  }\n  \n  // Cleanup expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now > entry.timestamp + entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\n// Global cache instance\nexport const globalResponseCache = new ResponseCache();\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  totalRequests: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  cacheHitRate: number;\n  errorRate: number;\n  lastUpdated: number;\n}\n\nexport class PerformanceMonitor {\n  private metrics: number[] = [];\n  private cacheHits = 0;\n  private cacheMisses = 0;\n  private errors = 0;\n  private readonly maxSamples = 1000;\n  \n  recordRequest(responseTimeMs: number, wasCacheHit: boolean, wasError: boolean): void {\n    // Record response time\n    this.metrics.push(responseTimeMs);\n    if (this.metrics.length > this.maxSamples) {\n      this.metrics.shift(); // Remove oldest\n    }\n    \n    // Record cache performance\n    if (wasCacheHit) {\n      this.cacheHits++;\n    } else {\n      this.cacheMisses++;\n    }\n    \n    // Record errors\n    if (wasError) {\n      this.errors++;\n    }\n  }\n  \n  getMetrics(): PerformanceMetrics {\n    if (this.metrics.length === 0) {\n      return {\n        totalRequests: 0,\n        averageResponseTime: 0,\n        p95ResponseTime: 0,\n        cacheHitRate: 0,\n        errorRate: 0,\n        lastUpdated: Date.now()\n      };\n    }\n    \n    const sorted = [...this.metrics].sort((a, b) => a - b);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    const totalCacheRequests = this.cacheHits + this.cacheMisses;\n    const totalRequests = this.metrics.length;\n    \n    return {\n      totalRequests,\n      averageResponseTime: this.metrics.reduce((a, b) => a + b, 0) / this.metrics.length,\n      p95ResponseTime: sorted[p95Index] || 0,\n      cacheHitRate: totalCacheRequests > 0 ? this.cacheHits / totalCacheRequests : 0,\n      errorRate: totalRequests > 0 ? this.errors / totalRequests : 0,\n      lastUpdated: Date.now()\n    };\n  }\n  \n  reset(): void {\n    this.metrics = [];\n    this.cacheHits = 0;\n    this.cacheMisses = 0;\n    this.errors = 0;\n  }\n}\n\n// Global performance monitor\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n\n// Simple hash function for cache keys\nexport function simpleHash(data: Uint8Array): string {\n  let hash = 0;\n  for (let i = 0; i < Math.min(data.length, 1000); i++) { // Sample first 1000 bytes\n    hash = ((hash << 5) - hash + data[i]) & 0xffffffff;\n  }\n  return hash.toString(36);\n}\n","// Production reliability utilities for Nadar shared core\n\nimport { Result, ProviderError } from '../types/api';\n\n// Retry configuration\nexport interface RetryConfig {\n  maxAttempts: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  backoffMultiplier: number;\n  retryableErrors: string[];\n  timeoutMs: number;\n}\n\n// Default retry configuration optimized for AI services\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  baseDelayMs: 1000,      // Start with 1s delay\n  maxDelayMs: 10000,      // Max 10s delay\n  backoffMultiplier: 2,   // Exponential backoff\n  retryableErrors: [\n    'RATE_LIMIT',\n    'TIMEOUT',\n    'NETWORK_ERROR',\n    'SERVICE_UNAVAILABLE',\n    'INTERNAL_ERROR'\n  ],\n  timeoutMs: 30000        // 30s timeout per attempt\n};\n\n// Circuit breaker states\nexport enum CircuitState {\n  CLOSED = 'CLOSED',      // Normal operation\n  OPEN = 'OPEN',          // Failing, reject requests\n  HALF_OPEN = 'HALF_OPEN' // Testing if service recovered\n}\n\n// Circuit breaker configuration\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;    // Failures before opening\n  recoveryTimeoutMs: number;   // Time before trying half-open\n  successThreshold: number;    // Successes needed to close\n  monitoringWindowMs: number;  // Window for failure counting\n}\n\nexport const DEFAULT_CIRCUIT_CONFIG: CircuitBreakerConfig = {\n  failureThreshold: 5,         // Open after 5 failures\n  recoveryTimeoutMs: 60000,    // Try recovery after 1 minute\n  successThreshold: 2,         // Close after 2 successes\n  monitoringWindowMs: 300000   // 5-minute monitoring window\n};\n\n// Enhanced error types with specific handling\nexport interface EnhancedError extends ProviderError {\n  isRetryable: boolean;\n  isTemporary: boolean;\n  suggestedAction: string;\n  originalError?: any;\n}\n\n// Retry utility with exponential backoff\nexport async function withRetry<T>(\n  operation: () => Promise<Result<T>>,\n  config: RetryConfig = DEFAULT_RETRY_CONFIG,\n  context: string = 'operation'\n): Promise<Result<T>> {\n  let lastError: EnhancedError | null = null;\n  \n  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n    try {\n      console.log(`🔄 ${context}: Attempt ${attempt}/${config.maxAttempts}`);\n      \n      // Add timeout to the operation\n      const result = await Promise.race([\n        operation(),\n        new Promise<Result<T>>((_, reject) => \n          setTimeout(() => reject(new Error('Operation timeout')), config.timeoutMs)\n        )\n      ]);\n      \n      if (result.ok) {\n        if (attempt > 1) {\n          console.log(`✅ ${context}: Succeeded on attempt ${attempt}`);\n        }\n        return result;\n      }\n      \n      // Enhance error with retry information\n      const errorResult = result as { ok: false; error: ProviderError };\n      const enhancedError = enhanceError(errorResult.error, config);\n      lastError = enhancedError;\n      \n      // Check if error is retryable\n      if (!enhancedError.isRetryable || attempt === config.maxAttempts) {\n        console.log(`❌ ${context}: Non-retryable error or max attempts reached`);\n        return { ok: false, error: enhancedError };\n      }\n      \n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt - 1),\n        config.maxDelayMs\n      );\n      \n      console.log(`⏳ ${context}: Retrying in ${delay}ms (attempt ${attempt + 1})`);\n      await sleep(delay);\n      \n    } catch (error: any) {\n      const enhancedError = enhanceError({\n        message: error.message || 'Unknown error',\n        err_code: 'UNKNOWN'\n      }, config);\n      \n      lastError = enhancedError;\n      \n      if (attempt === config.maxAttempts) {\n        console.log(`❌ ${context}: Max attempts reached with exception`);\n        return { ok: false, error: enhancedError };\n      }\n      \n      const delay = Math.min(\n        config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt - 1),\n        config.maxDelayMs\n      );\n      \n      console.log(`⏳ ${context}: Exception, retrying in ${delay}ms`);\n      await sleep(delay);\n    }\n  }\n  \n  return { ok: false, error: lastError! };\n}\n\n// Circuit breaker implementation\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures: number[] = [];\n  private successes: number = 0;\n  private lastFailureTime: number = 0;\n  private readonly config: CircuitBreakerConfig;\n  private readonly name: string;\n  \n  constructor(name: string, config: CircuitBreakerConfig = DEFAULT_CIRCUIT_CONFIG) {\n    this.name = name;\n    this.config = config;\n  }\n  \n  async execute<T>(operation: () => Promise<Result<T>>): Promise<Result<T>> {\n    // Check if circuit is open\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() - this.lastFailureTime < this.config.recoveryTimeoutMs) {\n        console.log(`🚫 Circuit breaker ${this.name} is OPEN, rejecting request`);\n        return {\n          ok: false,\n          error: {\n            message: `Service ${this.name} is temporarily unavailable`,\n            err_code: 'CIRCUIT_OPEN'\n          }\n        };\n      } else {\n        // Try half-open\n        this.state = CircuitState.HALF_OPEN;\n        this.successes = 0;\n        console.log(`🔄 Circuit breaker ${this.name} trying HALF_OPEN`);\n      }\n    }\n    \n    try {\n      const result = await operation();\n      \n      if (result.ok) {\n        this.onSuccess();\n        return result;\n      } else {\n        this.onFailure();\n        return result;\n      }\n    } catch (error: any) {\n      this.onFailure();\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Circuit breaker caught exception',\n          err_code: 'CIRCUIT_ERROR'\n        }\n      };\n    }\n  }\n  \n  private onSuccess(): void {\n    this.successes++;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      if (this.successes >= this.config.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.failures = [];\n        console.log(`✅ Circuit breaker ${this.name} is now CLOSED`);\n      }\n    }\n  }\n  \n  private onFailure(): void {\n    const now = Date.now();\n    this.lastFailureTime = now;\n    \n    // Clean old failures outside monitoring window\n    this.failures = this.failures.filter(\n      time => now - time < this.config.monitoringWindowMs\n    );\n    \n    this.failures.push(now);\n    \n    if (this.failures.length >= this.config.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.successes = 0;\n      console.log(`🚫 Circuit breaker ${this.name} is now OPEN`);\n    }\n  }\n  \n  getState(): { state: CircuitState; failures: number; successes: number } {\n    return {\n      state: this.state,\n      failures: this.failures.length,\n      successes: this.successes\n    };\n  }\n  \n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failures = [];\n    this.successes = 0;\n    this.lastFailureTime = 0;\n    console.log(`🔄 Circuit breaker ${this.name} manually reset`);\n  }\n}\n\n// Global circuit breakers for different services\nexport const geminiCircuitBreaker = new CircuitBreaker('Gemini');\nexport const elevenLabsCircuitBreaker = new CircuitBreaker('ElevenLabs');\n\n// Error enhancement utility\nfunction enhanceError(error: ProviderError, config: RetryConfig): EnhancedError {\n  const isRetryable = config.retryableErrors.includes(error.err_code);\n  \n  let suggestedAction = 'Contact support if problem persists';\n  let isTemporary = false;\n  \n  switch (error.err_code) {\n    case 'RATE_LIMIT':\n      suggestedAction = 'Reduce request frequency or upgrade API plan';\n      isTemporary = true;\n      break;\n    case 'TIMEOUT':\n      suggestedAction = 'Check network connection and try again';\n      isTemporary = true;\n      break;\n    case 'NETWORK_ERROR':\n      suggestedAction = 'Check internet connection';\n      isTemporary = true;\n      break;\n    case 'SERVICE_UNAVAILABLE':\n      suggestedAction = 'Service is temporarily down, try again later';\n      isTemporary = true;\n      break;\n    case 'INVALID_IMAGE':\n      suggestedAction = 'Use a different image or check image format';\n      isTemporary = false;\n      break;\n    case 'MISSING_API_KEY':\n      suggestedAction = 'Configure API key in environment variables';\n      isTemporary = false;\n      break;\n  }\n  \n  return {\n    ...error,\n    isRetryable,\n    isTemporary,\n    suggestedAction\n  };\n}\n\n// Utility functions\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Health check utilities\nexport interface HealthStatus {\n  service: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime?: number;\n  lastCheck: string;\n  circuitState?: CircuitState;\n  details?: string;\n}\n\nexport async function checkServiceHealth(\n  serviceName: string,\n  healthCheck: () => Promise<boolean>,\n  circuitBreaker?: CircuitBreaker\n): Promise<HealthStatus> {\n  const startTime = Date.now();\n  \n  try {\n    const isHealthy = await Promise.race([\n      healthCheck(),\n      new Promise<boolean>((_, reject) => \n        setTimeout(() => reject(new Error('Health check timeout')), 5000)\n      )\n    ]);\n    \n    const responseTime = Date.now() - startTime;\n    \n    return {\n      service: serviceName,\n      status: isHealthy ? 'healthy' : 'unhealthy',\n      responseTime,\n      lastCheck: new Date().toISOString(),\n      circuitState: circuitBreaker?.getState().state,\n      details: isHealthy ? 'Service responding normally' : 'Service check failed'\n    };\n  } catch (error: any) {\n    const responseTime = Date.now() - startTime;\n    \n    return {\n      service: serviceName,\n      status: 'unhealthy',\n      responseTime,\n      lastCheck: new Date().toISOString(),\n      circuitState: circuitBreaker?.getState().state,\n      details: error.message || 'Health check failed'\n    };\n  }\n}\n"],"mappings":"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","names":["responseTime"]}