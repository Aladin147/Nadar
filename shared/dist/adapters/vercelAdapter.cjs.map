{"version":3,"sources":["../../adapters/vercelAdapter.ts","../../core/assistCore.ts","../../core/ocrCore.ts"],"sourcesContent":["// Vercel adapter - maps VercelRequest to core types\n\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\nimport { AssistRequest, AssistDeps, RequestContext } from '../types/api';\nimport { handleAssist } from '../core/assistCore';\nimport { handleOCR, OCRRequest } from '../core/ocrCore';\n\n// Convert Vercel request to core AssistRequest\nfunction mapVercelRequest(req: VercelRequest): AssistRequest {\n  const body = req.body;\n\n  // Convert base64 image to Uint8Array if present\n  let image: Uint8Array | undefined;\n  if (body.imageBase64) {\n    image = new Uint8Array(Buffer.from(body.imageBase64, 'base64'));\n  }\n\n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    image,\n    imageRef: body.imageRef,\n    question: body.question,\n    language: body.options?.language || body.language || 'darija',\n    verbosity: body.options?.verbosity || body.verbosity || 'normal'\n  };\n}\n\n// Extract context from Vercel request\nfunction extractContext(req: VercelRequest): RequestContext {\n  return {\n    route_path: req.url || 'unknown',\n    remote_addr: req.headers['x-forwarded-for'] as string || 'unknown',\n    user_agent: req.headers['user-agent'] || 'unknown',\n    request_id: req.headers['x-request-id'] as string || `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  };\n}\n\n// Convert Vercel request to core OCRRequest\nfunction mapVercelOCRRequest(req: VercelRequest): OCRRequest {\n  const body = req.body;\n\n  // Convert base64 image to Uint8Array if present\n  let image: Uint8Array | undefined;\n  if (body.imageBase64) {\n    image = new Uint8Array(Buffer.from(body.imageBase64, 'base64'));\n  }\n\n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    image,\n    imageRef: body.imageRef,\n    full: body.full || false,\n    language: body.options?.language || body.language || 'darija'\n  };\n}\n\n// Vercel adapter for assist endpoint\nexport function createVercelAssistHandler(deps: AssistDeps) {\n  return async (req: VercelRequest, res: VercelResponse) => {\n    // Set headers\n    res.setHeader('cache-control', 'no-store');\n    res.setHeader('x-handler', 'shared-core');\n\n    // Check method\n    if (req.method !== 'POST') {\n      return res.status(405).json({\n        error: 'Method not allowed',\n        err_code: 'METHOD_NOT_ALLOWED'\n      });\n    }\n\n    try {\n      const coreRequest = mapVercelRequest(req);\n      const result = await handleAssist(coreRequest, deps);\n\n      if (result.ok) {\n        res.status(200).json(result.data);\n      } else {\n        const statusCode = result.error.err_code === 'VALIDATION_ERROR' ? 400 : 500;\n        res.status(statusCode).json({\n          error: result.error.message,\n          err_code: result.error.err_code,\n          details: result.error.details\n        });\n      }\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n\n// Vercel adapter for OCR endpoint\nexport function createVercelOCRHandler(deps: AssistDeps) {\n  return async (req: VercelRequest, res: VercelResponse) => {\n    // Set headers\n    res.setHeader('cache-control', 'no-store');\n    res.setHeader('x-handler', 'shared-core');\n\n    // Check method\n    if (req.method !== 'POST') {\n      return res.status(405).json({\n        error: 'Method not allowed',\n        err_code: 'METHOD_NOT_ALLOWED'\n      });\n    }\n\n    try {\n      const coreRequest = mapVercelOCRRequest(req);\n      const result = await handleOCR(coreRequest, deps);\n\n      if (result.ok) {\n        res.status(200).json(result.data);\n      } else {\n        const statusCode = result.error.err_code === 'VALIDATION_ERROR' ? 400 : 500;\n        res.status(statusCode).json({\n          error: result.error.message,\n          err_code: result.error.err_code,\n          details: result.error.details\n        });\n      }\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n","// Core business logic for assist endpoint - runtime agnostic\n\nimport { \n  AssistRequest, \n  AssistResponse, \n  AssistDeps, \n  Result, \n  ImageSignals,\n  ProviderError \n} from '../types/api';\n\nfunction createSystemPrompt(\n  language: string, \n  signals?: ImageSignals, \n  question?: string\n): string {\n  const langDir = language === 'ar' ? 'اكتب بالعربية الفصحى' : \n                  language === 'darija' ? 'اكتب بالدارجة المغربية' : \n                  'Write in English';\n\n  return `${langDir} You are نظر (Nadar), helping blind users navigate safely.\n\nFormat your response as a JSON object with exactly these fields:\n{\n  \"paragraph\": \"One short ${language === 'darija' ? 'Darija' : language} paragraph (≤2 sentences) with safety/next-step first\",\n  \"details\": [\"Additional detail 1\", \"Additional detail 2\", \"Additional detail 3\"],\n  \"has_text_content\": ${signals?.has_text ? 'true' : 'false'}\n}\n\nFor the paragraph:\n- Start with safety information or immediate next steps\n- Keep to maximum 2 sentences in ${language === 'darija' ? 'Darija' : language}\n- Be actionable and concise\n${question ? '- Answer the specific question first, then provide context' : ''}\n${signals?.has_text ? \n  '- IMPORTANT: Since text was detected, mention the visible text content prominently in your response' : \n  '- Focus on scene description and navigation guidance'}\n\nFor details array:\n- Provide 2-4 additional bullet points for \"More\" expansion\n- Include objects, navigation guidance, environmental context\n${signals?.has_text ? '- Include text-related details since text was detected' : ''}\n- Keep each detail concise but informative\n\nDon't identify people; avoid reading private screens; express uncertainty when unsure. Never use phrases like \"as you can see\" or \"if you look\".`;\n}\n\nfunction parseResponse(responseText: string): { paragraph: string; details: string[] } {\n  try {\n    // Remove markdown code blocks if present\n    let cleanedResponse = responseText.trim();\n    if (cleanedResponse.startsWith('```json')) {\n      cleanedResponse = cleanedResponse.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\n    } else if (cleanedResponse.startsWith('```')) {\n      cleanedResponse = cleanedResponse.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\n    }\n    \n    const parsed = JSON.parse(cleanedResponse);\n    if (parsed.paragraph && Array.isArray(parsed.details)) {\n      return {\n        paragraph: parsed.paragraph,\n        details: parsed.details\n      };\n    }\n  } catch (parseError) {\n    console.warn('Failed to parse single-paragraph JSON response, using fallback:', responseText);\n  }\n  \n  return {\n    paragraph: responseText,\n    details: []\n  };\n}\n\nfunction createFollowupSuggestions(language: string): string[] {\n  return language === 'darija' ? [\n    'نقرا النص كامل؟',\n    'فين الممر الخالي؟',\n    'شنو كاين حداي؟'\n  ] : [\n    'Read all text?',\n    'Where is the clear path?',\n    'What is next to me?'\n  ];\n}\n\n// Core assist handler - pure business logic\nexport async function handleAssist(\n  request: AssistRequest,\n  deps: AssistDeps\n): Promise<Result<AssistResponse>> {\n  const startTime = deps.now();\n  \n  try {\n    // Resolve image\n    let image: Uint8Array;\n    if (request.image) {\n      image = request.image;\n    } else if (request.imageRef) {\n      const cachedImage = await deps.imageStore.get(request.imageRef);\n      if (!cachedImage) {\n        const error = {\n          message: `No cached image found for imageRef: ${request.imageRef}`,\n          err_code: 'IMAGE_NOT_FOUND'\n        };\n\n        // Log error telemetry\n        deps.telemetry.log({\n          ts: new Date().toISOString(),\n          mode: 'assist',\n          engine: 'gemini',\n          route_path: '/assist',\n          image_bytes: 0,\n          audio_bytes_in: 0,\n          total_ms: deps.now() - startTime,\n          model_ms: 0,\n          tts_ms: 0,\n          chars_out: 0,\n          ok: false,\n          err_code: error.err_code,\n          request_id: request.sessionId\n        });\n\n        return { ok: false, error };\n      }\n      image = cachedImage;\n    } else {\n      const error = {\n        message: 'No valid image provided',\n        err_code: 'INVALID_IMAGE'\n      };\n\n      // Log error telemetry\n      deps.telemetry.log({\n        ts: new Date().toISOString(),\n        mode: 'assist',\n        engine: 'gemini',\n        route_path: '/assist',\n        image_bytes: 0,\n        audio_bytes_in: 0,\n        total_ms: deps.now() - startTime,\n        model_ms: 0,\n        tts_ms: 0,\n        chars_out: 0,\n        ok: false,\n        err_code: error.err_code,\n        request_id: request.sessionId\n      });\n\n      return { ok: false, error };\n    }\n    \n    // Step 1: Fast image inspection\n    const inspectionStart = deps.now();\n    const signalsResult = await deps.providers.inspectImage(image, 'image/jpeg');\n    if (!signalsResult.ok) {\n      return { ok: false, error: signalsResult.error };\n    }\n    const signals = signalsResult.data;\n    const inspectionTime = deps.now() - inspectionStart;\n    \n    // Step 2: Generate response\n    const processingStart = deps.now();\n    const language = request.language || 'darija';\n    const systemPrompt = createSystemPrompt(language, signals, request.question);\n    \n    const defaultPrompt = request.question || (language === 'darija' \n      ? 'ساعدني نفهم شنو كاين فهاد الصورة'\n      : 'Help me understand what is in this image');\n    \n    const responseResult = await deps.providers.generateResponse(\n      image,\n      'image/jpeg',\n      `${systemPrompt}\\n\\nUser: ${defaultPrompt}`\n    );\n\n    if (!responseResult.ok) {\n      return { ok: false, error: responseResult.error };\n    }\n    \n    const processingTime = deps.now() - processingStart;\n    \n    // Parse response\n    const { paragraph, details } = parseResponse(responseResult.data);\n    \n    // Generate followup suggestions\n    const followup_suggest = createFollowupSuggestions(language);\n    \n    // Save image for potential reuse and generate followup token\n    const followupToken = await deps.imageStore.save(image, 5); // 5 minute TTL\n    \n    const totalTime = deps.now() - startTime;\n    \n    // Log telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: request.question ? 'qa' : 'describe',\n      engine: 'gemini',\n      route_path: '/assist',\n      image_bytes: image.length,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: processingTime,\n      tts_ms: 0,\n      chars_out: paragraph.length + details.join('').length,\n      signals: signals,\n      ok: true,\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: true,\n      data: {\n        speak: paragraph,\n        details,\n        signals,\n        followup_suggest,\n        followupToken,\n        timing: {\n          inspection_ms: inspectionTime,\n          processing_ms: processingTime,\n          total_ms: totalTime\n        }\n      }\n    };\n    \n  } catch (error: any) {\n    const totalTime = deps.now() - startTime;\n    \n    // Log error telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'assist',\n      engine: 'gemini',\n      route_path: '/assist',\n      image_bytes: 0,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: 0,\n      tts_ms: 0,\n      chars_out: 0,\n      ok: false,\n      err_code: error.err_code || 'UNKNOWN',\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: false,\n      error: {\n        message: error.message || 'Internal server error',\n        err_code: error.err_code || 'UNKNOWN',\n        details: error.details\n      }\n    };\n  }\n}\n","// Core business logic for OCR endpoint - runtime agnostic\n\nimport { \n  Result, \n  ProviderError,\n  AssistDeps,\n  TelemetryData\n} from '../types/api';\n\nexport interface OCRRequest {\n  sessionId: string;\n  image?: Uint8Array;\n  imageRef?: string;\n  full?: boolean;\n  language?: 'darija' | 'ar' | 'en';\n}\n\nexport interface OCRResponse {\n  text: string;\n  timing: {\n    processing_ms: number;\n    total_ms: number;\n  };\n}\n\nfunction createOCRPrompt(language: string, full: boolean): string {\n  const langDir = language === 'ar' ? 'اكتب بالعربية الفصحى' : \n                  language === 'darija' ? 'اكتب بالدارجة المغربية' : \n                  'Write in English';\n\n  if (full) {\n    return `${langDir} Extract ALL text from this image. Include:\n- All readable text, signs, labels, captions\n- Text in any language or script\n- Numbers, dates, times\n- Menu items, prices, addresses\n- Any other textual content\n\nReturn only the extracted text, preserving the original structure and formatting where possible.`;\n  } else {\n    return `${langDir} Extract the main text content from this image. Focus on:\n- Primary text, headlines, main content\n- Important signs or labels\n- Key information that would be most relevant\n\nReturn only the extracted text in a clear, readable format.`;\n  }\n}\n\n// Core OCR handler - pure business logic\nexport async function handleOCR(\n  request: OCRRequest,\n  deps: AssistDeps\n): Promise<Result<OCRResponse>> {\n  const startTime = deps.now();\n  \n  try {\n    // Resolve image\n    let image: Uint8Array;\n    if (request.image) {\n      image = request.image;\n    } else if (request.imageRef) {\n      const cachedImage = await deps.imageStore.get(request.imageRef);\n      if (!cachedImage) {\n        const error = {\n          message: `No cached image found for imageRef: ${request.imageRef}`,\n          err_code: 'IMAGE_NOT_FOUND'\n        };\n        \n        // Log error telemetry\n        deps.telemetry.log({\n          ts: new Date().toISOString(),\n          mode: 'ocr',\n          engine: 'gemini',\n          route_path: '/ocr',\n          image_bytes: 0,\n          audio_bytes_in: 0,\n          total_ms: deps.now() - startTime,\n          model_ms: 0,\n          tts_ms: 0,\n          chars_out: 0,\n          ok: false,\n          err_code: error.err_code,\n          request_id: request.sessionId\n        });\n        \n        return { ok: false, error };\n      }\n      image = cachedImage;\n    } else {\n      const error = {\n        message: 'No valid image provided',\n        err_code: 'INVALID_IMAGE'\n      };\n      \n      // Log error telemetry\n      deps.telemetry.log({\n        ts: new Date().toISOString(),\n        mode: 'ocr',\n        engine: 'gemini',\n        route_path: '/ocr',\n        image_bytes: 0,\n        audio_bytes_in: 0,\n        total_ms: deps.now() - startTime,\n        model_ms: 0,\n        tts_ms: 0,\n        chars_out: 0,\n        ok: false,\n        err_code: error.err_code,\n        request_id: request.sessionId\n      });\n      \n      return { ok: false, error };\n    }\n    \n    // Generate OCR response\n    const processingStart = deps.now();\n    const language = request.language || 'darija';\n    const prompt = createOCRPrompt(language, request.full || false);\n    \n    const responseResult = await deps.providers.generateResponse(\n      image,\n      'image/jpeg',\n      prompt\n    );\n\n    if (!responseResult.ok) {\n      return { ok: false, error: responseResult.error };\n    }\n    \n    const processingTime = deps.now() - processingStart;\n    const totalTime = deps.now() - startTime;\n    const extractedText = responseResult.data.trim();\n    \n    // Log successful telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'ocr',\n      engine: 'gemini',\n      route_path: '/ocr',\n      image_bytes: image.length,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: processingTime,\n      tts_ms: 0,\n      chars_out: extractedText.length,\n      ok: true,\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: true,\n      data: {\n        text: extractedText,\n        timing: {\n          processing_ms: processingTime,\n          total_ms: totalTime\n        }\n      }\n    };\n    \n  } catch (error: any) {\n    const totalTime = deps.now() - startTime;\n    \n    // Log error telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'ocr',\n      engine: 'gemini',\n      route_path: '/ocr',\n      image_bytes: 0,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: 0,\n      tts_ms: 0,\n      chars_out: 0,\n      ok: false,\n      err_code: error.err_code || 'UNKNOWN',\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: false,\n      error: {\n        message: error.message || 'Internal server error',\n        err_code: error.err_code || 'UNKNOWN',\n        details: error.details\n      }\n    };\n  }\n}\n"],"mappings":"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","names":[]}