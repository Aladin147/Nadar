{"version":3,"sources":["../index.ts","../core/assistCore.ts","../adapters/expressAdapter.ts","../adapters/vercelAdapter.ts","../providers/geminiProvider.ts","../utils/performance.ts","../utils/reliability.ts","../providers/telemetryProvider.ts","../stores/imageStore.ts"],"sourcesContent":["// Main exports for @nadar/shared package\n\n// Core handlers\nexport { handleAssist } from './core/assistCore';\n\n// Adapters\nexport { createExpressAssistHandler } from './adapters/expressAdapter';\nexport { createVercelAssistHandler } from './adapters/vercelAdapter';\n\n// Providers\nexport { GeminiProvider } from './providers/geminiProvider';\nexport { ConsoleTelemetryLogger, RingBufferTelemetryLogger } from './providers/telemetryProvider';\n\n// Stores\nexport { MemoryImageStore, GlobalImageStore, VercelBlobImageStore } from './stores/imageStore';\n\n// Types\nexport type {\n  Result,\n  ProviderError,\n  ImageSignals,\n  AssistRequest,\n  AssistResponse,\n  AssistDeps,\n  AIProvider,\n  TelemetryLogger,\n  ImageStore,\n  RequestContext,\n  TelemetryData\n} from './types/api';\n","// Core business logic for assist endpoint - runtime agnostic\n\nimport { \n  AssistRequest, \n  AssistResponse, \n  AssistDeps, \n  Result, \n  ImageSignals,\n  ProviderError \n} from '../types/api';\n\nfunction createSystemPrompt(\n  language: string, \n  signals?: ImageSignals, \n  question?: string\n): string {\n  const langDir = language === 'ar' ? 'اكتب بالعربية الفصحى' : \n                  language === 'darija' ? 'اكتب بالدارجة المغربية' : \n                  'Write in English';\n\n  return `${langDir} You are نظر (Nadar), helping blind users navigate safely.\n\nFormat your response as a JSON object with exactly these fields:\n{\n  \"paragraph\": \"One short ${language === 'darija' ? 'Darija' : language} paragraph (≤2 sentences) with safety/next-step first\",\n  \"details\": [\"Additional detail 1\", \"Additional detail 2\", \"Additional detail 3\"],\n  \"has_text_content\": ${signals?.has_text ? 'true' : 'false'}\n}\n\nFor the paragraph:\n- Start with safety information or immediate next steps\n- Keep to maximum 2 sentences in ${language === 'darija' ? 'Darija' : language}\n- Be actionable and concise\n${question ? '- Answer the specific question first, then provide context' : ''}\n${signals?.has_text ? \n  '- IMPORTANT: Since text was detected, mention the visible text content prominently in your response' : \n  '- Focus on scene description and navigation guidance'}\n\nFor details array:\n- Provide 2-4 additional bullet points for \"More\" expansion\n- Include objects, navigation guidance, environmental context\n${signals?.has_text ? '- Include text-related details since text was detected' : ''}\n- Keep each detail concise but informative\n\nDon't identify people; avoid reading private screens; express uncertainty when unsure. Never use phrases like \"as you can see\" or \"if you look\".`;\n}\n\nfunction parseResponse(responseText: string): { paragraph: string; details: string[] } {\n  try {\n    // Remove markdown code blocks if present\n    let cleanedResponse = responseText.trim();\n    if (cleanedResponse.startsWith('```json')) {\n      cleanedResponse = cleanedResponse.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\n    } else if (cleanedResponse.startsWith('```')) {\n      cleanedResponse = cleanedResponse.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\n    }\n    \n    const parsed = JSON.parse(cleanedResponse);\n    if (parsed.paragraph && Array.isArray(parsed.details)) {\n      return {\n        paragraph: parsed.paragraph,\n        details: parsed.details\n      };\n    }\n  } catch (parseError) {\n    console.warn('Failed to parse single-paragraph JSON response, using fallback:', responseText);\n  }\n  \n  return {\n    paragraph: responseText,\n    details: []\n  };\n}\n\nfunction createFollowupSuggestions(language: string): string[] {\n  return language === 'darija' ? [\n    'نقرا النص كامل؟',\n    'فين الممر الخالي؟',\n    'شنو كاين حداي؟'\n  ] : [\n    'Read all text?',\n    'Where is the clear path?',\n    'What is next to me?'\n  ];\n}\n\n// Core assist handler - pure business logic\nexport async function handleAssist(\n  request: AssistRequest,\n  deps: AssistDeps\n): Promise<Result<AssistResponse>> {\n  const startTime = deps.now();\n  \n  try {\n    // Resolve image\n    let image: Uint8Array;\n    if (request.image) {\n      image = request.image;\n    } else if (request.imageRef) {\n      const cachedImage = await deps.imageStore.get(request.imageRef);\n      if (!cachedImage) {\n        const error = {\n          message: `No cached image found for imageRef: ${request.imageRef}`,\n          err_code: 'IMAGE_NOT_FOUND'\n        };\n\n        // Log error telemetry\n        deps.telemetry.log({\n          ts: new Date().toISOString(),\n          mode: 'assist',\n          engine: 'gemini',\n          route_path: '/assist',\n          image_bytes: 0,\n          audio_bytes_in: 0,\n          total_ms: deps.now() - startTime,\n          model_ms: 0,\n          tts_ms: 0,\n          chars_out: 0,\n          ok: false,\n          err_code: error.err_code,\n          request_id: request.sessionId\n        });\n\n        return { ok: false, error };\n      }\n      image = cachedImage;\n    } else {\n      const error = {\n        message: 'No valid image provided',\n        err_code: 'INVALID_IMAGE'\n      };\n\n      // Log error telemetry\n      deps.telemetry.log({\n        ts: new Date().toISOString(),\n        mode: 'assist',\n        engine: 'gemini',\n        route_path: '/assist',\n        image_bytes: 0,\n        audio_bytes_in: 0,\n        total_ms: deps.now() - startTime,\n        model_ms: 0,\n        tts_ms: 0,\n        chars_out: 0,\n        ok: false,\n        err_code: error.err_code,\n        request_id: request.sessionId\n      });\n\n      return { ok: false, error };\n    }\n    \n    // Step 1: Fast image inspection\n    const inspectionStart = deps.now();\n    const signalsResult = await deps.providers.inspectImage(image, 'image/jpeg');\n    if (!signalsResult.ok) {\n      const errorResult = signalsResult as { ok: false; error: ProviderError };\n      return { ok: false, error: errorResult.error };\n    }\n    const signals = signalsResult.data;\n    const inspectionTime = deps.now() - inspectionStart;\n    \n    // Step 2: Generate response\n    const processingStart = deps.now();\n    const language = request.language || 'darija';\n    const systemPrompt = createSystemPrompt(language, signals, request.question);\n    \n    const defaultPrompt = request.question || (language === 'darija' \n      ? 'ساعدني نفهم شنو كاين فهاد الصورة'\n      : 'Help me understand what is in this image');\n    \n    const responseResult = await deps.providers.generateResponse(\n      image,\n      'image/jpeg',\n      `${systemPrompt}\\n\\nUser: ${defaultPrompt}`\n    );\n\n    if (!responseResult.ok) {\n      const errorResult = responseResult as { ok: false; error: ProviderError };\n      return { ok: false, error: errorResult.error };\n    }\n    \n    const processingTime = deps.now() - processingStart;\n    \n    // Parse response\n    const { paragraph, details } = parseResponse(responseResult.data);\n    \n    // Generate followup suggestions\n    const followup_suggest = createFollowupSuggestions(language);\n    \n    // Save image for potential reuse and generate followup token\n    const followupToken = await deps.imageStore.save(image, 5); // 5 minute TTL\n    \n    const totalTime = deps.now() - startTime;\n    \n    // Log telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: request.question ? 'qa' : 'describe',\n      engine: 'gemini',\n      route_path: '/assist',\n      image_bytes: image.length,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: processingTime,\n      tts_ms: 0,\n      chars_out: paragraph.length + details.join('').length,\n      signals: signals,\n      ok: true,\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: true,\n      data: {\n        speak: paragraph,\n        details,\n        signals,\n        followup_suggest,\n        followupToken,\n        timing: {\n          inspection_ms: inspectionTime,\n          processing_ms: processingTime,\n          total_ms: totalTime\n        }\n      }\n    };\n    \n  } catch (error: any) {\n    const totalTime = deps.now() - startTime;\n    \n    // Log error telemetry\n    deps.telemetry.log({\n      ts: new Date().toISOString(),\n      mode: 'assist',\n      engine: 'gemini',\n      route_path: '/assist',\n      image_bytes: 0,\n      audio_bytes_in: 0,\n      total_ms: totalTime,\n      model_ms: 0,\n      tts_ms: 0,\n      chars_out: 0,\n      ok: false,\n      err_code: error.err_code || 'UNKNOWN',\n      request_id: request.sessionId\n    });\n    \n    return {\n      ok: false,\n      error: {\n        message: error.message || 'Internal server error',\n        err_code: error.err_code || 'UNKNOWN',\n        details: error.details\n      }\n    };\n  }\n}\n","// Express adapter - maps Express req/res to core types\n\nimport type { Request, Response } from 'express';\nimport { AssistRequest, AssistDeps, RequestContext } from '../types/api';\nimport { handleAssist } from '../core/assistCore';\n\n// Convert Express request to core AssistRequest\nfunction mapExpressRequest(req: Request): AssistRequest {\n  const body = req.body;\n  \n  // Convert base64 image to Uint8Array if present\n  let image: Uint8Array | undefined;\n  if (body.imageBase64) {\n    image = new Uint8Array(Buffer.from(body.imageBase64, 'base64'));\n  }\n  \n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    image,\n    imageRef: body.imageRef,\n    question: body.question,\n    language: body.options?.language || body.language || 'darija',\n    verbosity: body.options?.verbosity || body.verbosity || 'normal'\n  };\n}\n\n// Extract context from Express request\nfunction extractContext(req: Request): RequestContext {\n  return {\n    route_path: req.path,\n    remote_addr: req.ip || req.connection?.remoteAddress || 'unknown',\n    user_agent: req.headers['user-agent'] || 'unknown',\n    request_id: req.headers['x-request-id'] as string || `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  };\n}\n\n// Express adapter for assist endpoint\nexport function createExpressAssistHandler(deps: AssistDeps) {\n  return async (req: Request, res: Response) => {\n    try {\n      const coreRequest = mapExpressRequest(req);\n      const result = await handleAssist(coreRequest, deps);\n      \n      if (result.ok) {\n        res.json(result.data);\n      } else {\n        const statusCode = result.error.err_code === 'VALIDATION_ERROR' ? 400 : 500;\n        res.status(statusCode).json({\n          error: result.error.message,\n          err_code: result.error.err_code,\n          details: result.error.details\n        });\n      }\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n","// Vercel adapter - maps VercelRequest to core types\n\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\nimport { AssistRequest, AssistDeps, RequestContext, Result, ProviderError } from '../types/api';\nimport { handleAssist } from '../core/assistCore';\nimport { handleOCR, OCRRequest } from '../core/ocrCore';\nimport { handleTTS, TTSRequest, TTSDeps } from '../core/ttsCore';\n\n// Helper function to handle Result responses\nfunction handleResult<T>(result: Result<T>, res: VercelResponse): void {\n  if (result.ok) {\n    res.status(200).json(result.data);\n  } else {\n    // TypeScript now knows result is the error variant\n    const errorResult = result as { ok: false; error: ProviderError };\n    const statusCode = errorResult.error.err_code === 'VALIDATION_ERROR' ? 400 : 500;\n    res.status(statusCode).json({\n      error: errorResult.error.message,\n      err_code: errorResult.error.err_code,\n      details: errorResult.error.details\n    });\n  }\n}\n\n// Convert Vercel request to core AssistRequest\nfunction mapVercelRequest(req: VercelRequest): AssistRequest {\n  const body = req.body;\n\n  // Convert base64 image to Uint8Array if present\n  let image: Uint8Array | undefined;\n  if (body.imageBase64) {\n    image = new Uint8Array(Buffer.from(body.imageBase64, 'base64'));\n  }\n\n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    image,\n    imageRef: body.imageRef,\n    question: body.question,\n    language: body.options?.language || body.language || 'darija',\n    verbosity: body.options?.verbosity || body.verbosity || 'normal'\n  };\n}\n\n// Extract context from Vercel request\nfunction extractContext(req: VercelRequest): RequestContext {\n  return {\n    route_path: req.url || 'unknown',\n    remote_addr: req.headers['x-forwarded-for'] as string || 'unknown',\n    user_agent: req.headers['user-agent'] || 'unknown',\n    request_id: req.headers['x-request-id'] as string || `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  };\n}\n\n// Convert Vercel request to core OCRRequest\nfunction mapVercelOCRRequest(req: VercelRequest): OCRRequest {\n  const body = req.body;\n\n  // Convert base64 image to Uint8Array if present\n  let image: Uint8Array | undefined;\n  if (body.imageBase64) {\n    image = new Uint8Array(Buffer.from(body.imageBase64, 'base64'));\n  }\n\n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    image,\n    imageRef: body.imageRef,\n    full: body.full || false,\n    language: body.options?.language || body.language || 'darija'\n  };\n}\n\n// Convert Vercel request to core TTSRequest\nfunction mapVercelTTSRequest(req: VercelRequest): TTSRequest {\n  const body = req.body;\n\n  return {\n    sessionId: body.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    text: body.text,\n    voice: body.voice,\n    provider: body.provider || 'gemini',\n    rate: body.rate\n  };\n}\n\n// Vercel adapter for assist endpoint\nexport function createVercelAssistHandler(deps: AssistDeps) {\n  return async (req: VercelRequest, res: VercelResponse) => {\n    // Set headers\n    res.setHeader('cache-control', 'no-store');\n    res.setHeader('x-handler', 'shared-core');\n\n    // Check method\n    if (req.method !== 'POST') {\n      return res.status(405).json({\n        error: 'Method not allowed',\n        err_code: 'METHOD_NOT_ALLOWED'\n      });\n    }\n\n    try {\n      const coreRequest = mapVercelRequest(req);\n      const result = await handleAssist(coreRequest, deps);\n      handleResult(result, res);\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n\n// Vercel adapter for OCR endpoint\nexport function createVercelOCRHandler(deps: AssistDeps) {\n  return async (req: VercelRequest, res: VercelResponse) => {\n    // Set headers\n    res.setHeader('cache-control', 'no-store');\n    res.setHeader('x-handler', 'shared-core');\n\n    // Check method\n    if (req.method !== 'POST') {\n      return res.status(405).json({\n        error: 'Method not allowed',\n        err_code: 'METHOD_NOT_ALLOWED'\n      });\n    }\n\n    try {\n      const coreRequest = mapVercelOCRRequest(req);\n      const result = await handleOCR(coreRequest, deps);\n      handleResult(result, res);\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n\n// Vercel adapter for TTS endpoint\nexport function createVercelTTSHandler(deps: TTSDeps) {\n  return async (req: VercelRequest, res: VercelResponse) => {\n    // Set headers\n    res.setHeader('cache-control', 'no-store');\n    res.setHeader('x-handler', 'shared-core');\n\n    // Check method\n    if (req.method !== 'POST') {\n      return res.status(405).json({\n        error: 'Method not allowed',\n        err_code: 'METHOD_NOT_ALLOWED'\n      });\n    }\n\n    try {\n      const coreRequest = mapVercelTTSRequest(req);\n      const result = await handleTTS(coreRequest, deps);\n      handleResult(result, res);\n    } catch (error: any) {\n      res.status(500).json({\n        error: error.message || 'Internal server error',\n        err_code: 'UNKNOWN'\n      });\n    }\n  };\n}\n","// Gemini AI provider implementation with performance optimizations\n\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { AIProvider, Result, ImageSignals, ProviderError } from '../types/api';\nimport {\n  PerformanceConfig,\n  DEFAULT_PERFORMANCE_CONFIG,\n  optimizeImageForAI,\n  createOptimizedPrompt,\n  globalResponseCache,\n  globalPerformanceMonitor,\n  simpleHash\n} from '../utils/performance';\nimport {\n  withRetry,\n  geminiCircuitBreaker,\n  DEFAULT_RETRY_CONFIG,\n  RetryConfig,\n  checkServiceHealth,\n  HealthStatus\n} from '../utils/reliability';\n\nexport class GeminiProvider implements AIProvider {\n  private genAI: GoogleGenerativeAI;\n  private config: PerformanceConfig;\n  private retryConfig: RetryConfig;\n\n  constructor(\n    apiKey: string,\n    config?: Partial<PerformanceConfig>,\n    retryConfig?: Partial<RetryConfig>\n  ) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.config = { ...DEFAULT_PERFORMANCE_CONFIG, ...config };\n    this.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n  }\n\n  async inspectImage(image: Uint8Array, mimeType: string): Promise<Result<ImageSignals>> {\n    // Wrap with circuit breaker and retry logic\n    return await geminiCircuitBreaker.execute(async () => {\n      return await withRetry(async () => {\n        return await this.performInspection(image, mimeType);\n      }, this.retryConfig, 'Gemini Image Inspection');\n    });\n  }\n\n  private async performInspection(image: Uint8Array, mimeType: string): Promise<Result<ImageSignals>> {\n    const startTime = Date.now();\n\n    try {\n      // Use fastest model for inspection\n      const model = this.genAI.getGenerativeModel({ model: this.config.fastModel });\n      \n      const prompt = `Analyze this image quickly and return ONLY a JSON object with these exact fields:\n{\n  \"has_text\": boolean (true if any readable text is visible),\n  \"hazards\": string[] (list of safety hazards like \"moving vehicle\", \"stairs\", \"obstacle\", max 3),\n  \"people_count\": number (count of people visible, 0-10+),\n  \"lighting_ok\": boolean (true if lighting is adequate for clear vision),\n  \"confidence\": number (0.0-1.0, overall confidence in analysis)\n}\n\nBe concise and accurate. Return only valid JSON.`;\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        prompt,\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        }\n      ]);\n\n      const responseText = result.response.text().trim();\n      \n      try {\n        const signals = JSON.parse(responseText);\n\n        const responseTime = Date.now() - startTime;\n        globalPerformanceMonitor.recordRequest(responseTime, false, false);\n        console.log(`⚡ Fast inspection completed in ${responseTime}ms`);\n\n        return {\n          ok: true,\n          data: {\n            has_text: Boolean(signals.has_text),\n            hazards: Array.isArray(signals.hazards) ? signals.hazards.slice(0, 3).map(String) : [],\n            people_count: Math.max(0, Math.min(10, Number(signals.people_count) || 0)),\n            lighting_ok: Boolean(signals.lighting_ok),\n            confidence: Math.max(0, Math.min(1, Number(signals.confidence) || 0))\n          }\n        };\n      } catch (parseError) {\n        console.warn('Failed to parse image inspector JSON:', responseText);\n        return {\n          ok: true,\n          data: {\n            has_text: responseText.toLowerCase().includes('text'),\n            hazards: [],\n            people_count: 0,\n            lighting_ok: true,\n            confidence: 0.5\n          }\n        };\n      }\n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, true);\n\n      console.error('Image inspection failed:', error);\n\n      // Map specific error types for better retry logic\n      let errorCode = 'INSPECTION_ERROR';\n      if (error.message?.includes('quota') || error.message?.includes('rate limit')) {\n        errorCode = 'RATE_LIMIT';\n      } else if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {\n        errorCode = 'TIMEOUT';\n      } else if (error.message?.includes('network') || error.code === 'ENOTFOUND') {\n        errorCode = 'NETWORK_ERROR';\n      } else if (error.status >= 500) {\n        errorCode = 'SERVICE_UNAVAILABLE';\n      }\n\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Image inspection failed',\n          err_code: errorCode,\n          details: error.toString()\n        }\n      };\n    }\n  }\n\n  async generateResponse(image: Uint8Array, mimeType: string, prompt: string): Promise<Result<string>> {\n    // Wrap with circuit breaker and retry logic\n    return await geminiCircuitBreaker.execute(async () => {\n      return await withRetry(async () => {\n        return await this.performGeneration(image, mimeType, prompt);\n      }, this.retryConfig, 'Gemini Response Generation');\n    });\n  }\n\n  private async performGeneration(image: Uint8Array, mimeType: string, prompt: string): Promise<Result<string>> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const imageHash = simpleHash(image);\n      const cacheKey = globalResponseCache.generateKey(imageHash, 'darija', prompt.includes('question') ? 'qa' : undefined);\n\n      if (this.config.enableResponseCache) {\n        const cachedResponse = globalResponseCache.get(cacheKey);\n        if (cachedResponse) {\n          const responseTime = Date.now() - startTime;\n          globalPerformanceMonitor.recordRequest(responseTime, true, false);\n          console.log(`⚡ Cache hit! Response served in ${responseTime}ms`);\n          return { ok: true, data: cachedResponse };\n        }\n      }\n\n      // Use quality model for main response\n      const model = this.genAI.getGenerativeModel({ model: this.config.qualityModel });\n\n      // Optimize image if needed\n      const optimizedImage = optimizeImageForAI(image, this.config);\n      const imageBase64 = Buffer.from(optimizedImage).toString('base64');\n      \n      const result = await model.generateContent([\n        {\n          inlineData: {\n            data: imageBase64,\n            mimeType\n          }\n        },\n        { text: prompt }\n      ]);\n\n      const response = await result.response;\n      const text = response.text();\n\n      // Cache the response\n      if (this.config.enableResponseCache) {\n        globalResponseCache.set(cacheKey, text);\n      }\n\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, false);\n      console.log(`⚡ Response generated in ${responseTime}ms`);\n\n      return {\n        ok: true,\n        data: text\n      };\n      \n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      globalPerformanceMonitor.recordRequest(responseTime, false, true);\n\n      console.error('Response generation failed:', error);\n\n      // Map specific error types for better retry logic\n      let errorCode = 'GENERATION_ERROR';\n      if (error.message?.includes('quota') || error.message?.includes('rate limit')) {\n        errorCode = 'RATE_LIMIT';\n      } else if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {\n        errorCode = 'TIMEOUT';\n      } else if (error.message?.includes('network') || error.code === 'ENOTFOUND') {\n        errorCode = 'NETWORK_ERROR';\n      } else if (error.status >= 500) {\n        errorCode = 'SERVICE_UNAVAILABLE';\n      } else if (error.message?.includes('API key')) {\n        errorCode = 'MISSING_API_KEY';\n      }\n\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Response generation failed',\n          err_code: errorCode,\n          details: error.toString()\n        }\n      };\n    }\n  }\n\n  // Health check method\n  async checkHealth(): Promise<HealthStatus> {\n    return await checkServiceHealth(\n      'Gemini',\n      async () => {\n        try {\n          // Simple health check with minimal image\n          const testImage = new Uint8Array([137, 80, 78, 71]); // PNG header\n          const result = await this.performInspection(testImage, 'image/png');\n          // Even if it fails due to invalid image, if we get a response, service is up\n          return true;\n        } catch (error) {\n          return false;\n        }\n      },\n      geminiCircuitBreaker\n    );\n  }\n\n  // Get circuit breaker status\n  getCircuitBreakerStatus() {\n    return geminiCircuitBreaker.getState();\n  }\n\n  // Reset circuit breaker (for admin/debugging)\n  resetCircuitBreaker() {\n    geminiCircuitBreaker.reset();\n  }\n}\n","// Performance optimization utilities for Nadar shared core\n\nimport { ImageSignals } from '../types/api';\n\n// Performance configuration\nexport interface PerformanceConfig {\n  // Gemini model selection for speed vs quality tradeoff\n  fastModel: string;      // For inspection (speed priority)\n  qualityModel: string;   // For main response (quality priority)\n  \n  // Prompt optimization\n  maxPromptLength: number;\n  useCompactPrompts: boolean;\n  \n  // Image optimization\n  maxImageSize: number;   // Max bytes before compression\n  compressionQuality: number; // 0.1-1.0\n  \n  // Parallel processing\n  enableParallelInspection: boolean;\n  \n  // Caching\n  enableResponseCache: boolean;\n  cacheKeyFields: string[];\n}\n\n// Default performance configuration optimized for 3-4s target\nexport const DEFAULT_PERFORMANCE_CONFIG: PerformanceConfig = {\n  fastModel: 'gemini-2.5-flash-lite',     // Fastest for inspection\n  qualityModel: 'gemini-2.5-flash',       // Balanced for main response\n  maxPromptLength: 1000,                  // Shorter prompts = faster\n  useCompactPrompts: true,                // Use optimized prompt templates\n  maxImageSize: 1024 * 1024,             // 1MB max before compression\n  compressionQuality: 0.8,                // Good quality/speed balance\n  enableParallelInspection: false,        // Keep sequential for now\n  enableResponseCache: true,              // Cache similar requests\n  cacheKeyFields: ['image_hash', 'language', 'question_type']\n};\n\n// Image optimization utilities\nexport function optimizeImageForAI(imageBuffer: Uint8Array, config: PerformanceConfig): Uint8Array {\n  // If image is already small enough, return as-is\n  if (imageBuffer.length <= config.maxImageSize) {\n    return imageBuffer;\n  }\n  \n  // For now, return original - would implement compression here\n  // TODO: Implement actual image compression using sharp or similar\n  console.log(`⚡ Image size ${imageBuffer.length} bytes exceeds ${config.maxImageSize}, compression needed`);\n  return imageBuffer;\n}\n\n// Prompt optimization utilities\nexport function createOptimizedPrompt(\n  basePrompt: string, \n  signals: ImageSignals, \n  config: PerformanceConfig\n): string {\n  if (!config.useCompactPrompts) {\n    return basePrompt;\n  }\n  \n  // Create more focused prompts based on signals\n  let optimizedPrompt = basePrompt;\n  \n  // If no text detected, skip text-related instructions\n  if (!signals.has_text) {\n    optimizedPrompt = optimizedPrompt.replace(/text|reading|signs|labels/gi, '');\n  }\n  \n  // If no people detected, skip people-related instructions\n  if (signals.people_count === 0) {\n    optimizedPrompt = optimizedPrompt.replace(/people|person|individuals/gi, '');\n  }\n  \n  // Truncate if too long\n  if (optimizedPrompt.length > config.maxPromptLength) {\n    optimizedPrompt = optimizedPrompt.substring(0, config.maxPromptLength) + '...';\n  }\n  \n  return optimizedPrompt;\n}\n\n// Response caching utilities\nexport interface CacheEntry {\n  response: string;\n  timestamp: number;\n  ttl: number; // Time to live in milliseconds\n}\n\nexport class ResponseCache {\n  private cache = new Map<string, CacheEntry>();\n  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes\n  \n  generateKey(imageHash: string, language: string, question?: string): string {\n    const questionType = question ? 'qa' : 'describe';\n    return `${imageHash}-${language}-${questionType}`;\n  }\n  \n  get(key: string): string | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    \n    // Check if expired\n    if (Date.now() > entry.timestamp + entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.response;\n  }\n  \n  set(key: string, response: string, ttl?: number): void {\n    this.cache.set(key, {\n      response,\n      timestamp: Date.now(),\n      ttl: ttl || this.defaultTTL\n    });\n  }\n  \n  clear(): void {\n    this.cache.clear();\n  }\n  \n  // Cleanup expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now > entry.timestamp + entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\n// Global cache instance\nexport const globalResponseCache = new ResponseCache();\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  totalRequests: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  cacheHitRate: number;\n  errorRate: number;\n  lastUpdated: number;\n}\n\nexport class PerformanceMonitor {\n  private metrics: number[] = [];\n  private cacheHits = 0;\n  private cacheMisses = 0;\n  private errors = 0;\n  private readonly maxSamples = 1000;\n  \n  recordRequest(responseTimeMs: number, wasCacheHit: boolean, wasError: boolean): void {\n    // Record response time\n    this.metrics.push(responseTimeMs);\n    if (this.metrics.length > this.maxSamples) {\n      this.metrics.shift(); // Remove oldest\n    }\n    \n    // Record cache performance\n    if (wasCacheHit) {\n      this.cacheHits++;\n    } else {\n      this.cacheMisses++;\n    }\n    \n    // Record errors\n    if (wasError) {\n      this.errors++;\n    }\n  }\n  \n  getMetrics(): PerformanceMetrics {\n    if (this.metrics.length === 0) {\n      return {\n        totalRequests: 0,\n        averageResponseTime: 0,\n        p95ResponseTime: 0,\n        cacheHitRate: 0,\n        errorRate: 0,\n        lastUpdated: Date.now()\n      };\n    }\n    \n    const sorted = [...this.metrics].sort((a, b) => a - b);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    const totalCacheRequests = this.cacheHits + this.cacheMisses;\n    const totalRequests = this.metrics.length;\n    \n    return {\n      totalRequests,\n      averageResponseTime: this.metrics.reduce((a, b) => a + b, 0) / this.metrics.length,\n      p95ResponseTime: sorted[p95Index] || 0,\n      cacheHitRate: totalCacheRequests > 0 ? this.cacheHits / totalCacheRequests : 0,\n      errorRate: totalRequests > 0 ? this.errors / totalRequests : 0,\n      lastUpdated: Date.now()\n    };\n  }\n  \n  reset(): void {\n    this.metrics = [];\n    this.cacheHits = 0;\n    this.cacheMisses = 0;\n    this.errors = 0;\n  }\n}\n\n// Global performance monitor\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n\n// Simple hash function for cache keys\nexport function simpleHash(data: Uint8Array): string {\n  let hash = 0;\n  for (let i = 0; i < Math.min(data.length, 1000); i++) { // Sample first 1000 bytes\n    hash = ((hash << 5) - hash + data[i]) & 0xffffffff;\n  }\n  return hash.toString(36);\n}\n","// Production reliability utilities for Nadar shared core\n\nimport { Result, ProviderError } from '../types/api';\n\n// Retry configuration\nexport interface RetryConfig {\n  maxAttempts: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  backoffMultiplier: number;\n  retryableErrors: string[];\n  timeoutMs: number;\n}\n\n// Default retry configuration optimized for AI services\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  baseDelayMs: 1000,      // Start with 1s delay\n  maxDelayMs: 10000,      // Max 10s delay\n  backoffMultiplier: 2,   // Exponential backoff\n  retryableErrors: [\n    'RATE_LIMIT',\n    'TIMEOUT',\n    'NETWORK_ERROR',\n    'SERVICE_UNAVAILABLE',\n    'INTERNAL_ERROR'\n  ],\n  timeoutMs: 30000        // 30s timeout per attempt\n};\n\n// Circuit breaker states\nexport enum CircuitState {\n  CLOSED = 'CLOSED',      // Normal operation\n  OPEN = 'OPEN',          // Failing, reject requests\n  HALF_OPEN = 'HALF_OPEN' // Testing if service recovered\n}\n\n// Circuit breaker configuration\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;    // Failures before opening\n  recoveryTimeoutMs: number;   // Time before trying half-open\n  successThreshold: number;    // Successes needed to close\n  monitoringWindowMs: number;  // Window for failure counting\n}\n\nexport const DEFAULT_CIRCUIT_CONFIG: CircuitBreakerConfig = {\n  failureThreshold: 5,         // Open after 5 failures\n  recoveryTimeoutMs: 60000,    // Try recovery after 1 minute\n  successThreshold: 2,         // Close after 2 successes\n  monitoringWindowMs: 300000   // 5-minute monitoring window\n};\n\n// Enhanced error types with specific handling\nexport interface EnhancedError extends ProviderError {\n  isRetryable: boolean;\n  isTemporary: boolean;\n  suggestedAction: string;\n  originalError?: any;\n}\n\n// Retry utility with exponential backoff\nexport async function withRetry<T>(\n  operation: () => Promise<Result<T>>,\n  config: RetryConfig = DEFAULT_RETRY_CONFIG,\n  context: string = 'operation'\n): Promise<Result<T>> {\n  let lastError: EnhancedError | null = null;\n  \n  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n    try {\n      console.log(`🔄 ${context}: Attempt ${attempt}/${config.maxAttempts}`);\n      \n      // Add timeout to the operation\n      const result = await Promise.race([\n        operation(),\n        new Promise<Result<T>>((_, reject) => \n          setTimeout(() => reject(new Error('Operation timeout')), config.timeoutMs)\n        )\n      ]);\n      \n      if (result.ok) {\n        if (attempt > 1) {\n          console.log(`✅ ${context}: Succeeded on attempt ${attempt}`);\n        }\n        return result;\n      }\n      \n      // Enhance error with retry information\n      const errorResult = result as { ok: false; error: ProviderError };\n      const enhancedError = enhanceError(errorResult.error, config);\n      lastError = enhancedError;\n      \n      // Check if error is retryable\n      if (!enhancedError.isRetryable || attempt === config.maxAttempts) {\n        console.log(`❌ ${context}: Non-retryable error or max attempts reached`);\n        return { ok: false, error: enhancedError };\n      }\n      \n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt - 1),\n        config.maxDelayMs\n      );\n      \n      console.log(`⏳ ${context}: Retrying in ${delay}ms (attempt ${attempt + 1})`);\n      await sleep(delay);\n      \n    } catch (error: any) {\n      const enhancedError = enhanceError({\n        message: error.message || 'Unknown error',\n        err_code: 'UNKNOWN'\n      }, config);\n      \n      lastError = enhancedError;\n      \n      if (attempt === config.maxAttempts) {\n        console.log(`❌ ${context}: Max attempts reached with exception`);\n        return { ok: false, error: enhancedError };\n      }\n      \n      const delay = Math.min(\n        config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt - 1),\n        config.maxDelayMs\n      );\n      \n      console.log(`⏳ ${context}: Exception, retrying in ${delay}ms`);\n      await sleep(delay);\n    }\n  }\n  \n  return { ok: false, error: lastError! };\n}\n\n// Circuit breaker implementation\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures: number[] = [];\n  private successes: number = 0;\n  private lastFailureTime: number = 0;\n  private readonly config: CircuitBreakerConfig;\n  private readonly name: string;\n  \n  constructor(name: string, config: CircuitBreakerConfig = DEFAULT_CIRCUIT_CONFIG) {\n    this.name = name;\n    this.config = config;\n  }\n  \n  async execute<T>(operation: () => Promise<Result<T>>): Promise<Result<T>> {\n    // Check if circuit is open\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() - this.lastFailureTime < this.config.recoveryTimeoutMs) {\n        console.log(`🚫 Circuit breaker ${this.name} is OPEN, rejecting request`);\n        return {\n          ok: false,\n          error: {\n            message: `Service ${this.name} is temporarily unavailable`,\n            err_code: 'CIRCUIT_OPEN'\n          }\n        };\n      } else {\n        // Try half-open\n        this.state = CircuitState.HALF_OPEN;\n        this.successes = 0;\n        console.log(`🔄 Circuit breaker ${this.name} trying HALF_OPEN`);\n      }\n    }\n    \n    try {\n      const result = await operation();\n      \n      if (result.ok) {\n        this.onSuccess();\n        return result;\n      } else {\n        this.onFailure();\n        return result;\n      }\n    } catch (error: any) {\n      this.onFailure();\n      return {\n        ok: false,\n        error: {\n          message: error.message || 'Circuit breaker caught exception',\n          err_code: 'CIRCUIT_ERROR'\n        }\n      };\n    }\n  }\n  \n  private onSuccess(): void {\n    this.successes++;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      if (this.successes >= this.config.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.failures = [];\n        console.log(`✅ Circuit breaker ${this.name} is now CLOSED`);\n      }\n    }\n  }\n  \n  private onFailure(): void {\n    const now = Date.now();\n    this.lastFailureTime = now;\n    \n    // Clean old failures outside monitoring window\n    this.failures = this.failures.filter(\n      time => now - time < this.config.monitoringWindowMs\n    );\n    \n    this.failures.push(now);\n    \n    if (this.failures.length >= this.config.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.successes = 0;\n      console.log(`🚫 Circuit breaker ${this.name} is now OPEN`);\n    }\n  }\n  \n  getState(): { state: CircuitState; failures: number; successes: number } {\n    return {\n      state: this.state,\n      failures: this.failures.length,\n      successes: this.successes\n    };\n  }\n  \n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failures = [];\n    this.successes = 0;\n    this.lastFailureTime = 0;\n    console.log(`🔄 Circuit breaker ${this.name} manually reset`);\n  }\n}\n\n// Global circuit breakers for different services\nexport const geminiCircuitBreaker = new CircuitBreaker('Gemini');\nexport const elevenLabsCircuitBreaker = new CircuitBreaker('ElevenLabs');\n\n// Error enhancement utility\nfunction enhanceError(error: ProviderError, config: RetryConfig): EnhancedError {\n  const isRetryable = config.retryableErrors.includes(error.err_code);\n  \n  let suggestedAction = 'Contact support if problem persists';\n  let isTemporary = false;\n  \n  switch (error.err_code) {\n    case 'RATE_LIMIT':\n      suggestedAction = 'Reduce request frequency or upgrade API plan';\n      isTemporary = true;\n      break;\n    case 'TIMEOUT':\n      suggestedAction = 'Check network connection and try again';\n      isTemporary = true;\n      break;\n    case 'NETWORK_ERROR':\n      suggestedAction = 'Check internet connection';\n      isTemporary = true;\n      break;\n    case 'SERVICE_UNAVAILABLE':\n      suggestedAction = 'Service is temporarily down, try again later';\n      isTemporary = true;\n      break;\n    case 'INVALID_IMAGE':\n      suggestedAction = 'Use a different image or check image format';\n      isTemporary = false;\n      break;\n    case 'MISSING_API_KEY':\n      suggestedAction = 'Configure API key in environment variables';\n      isTemporary = false;\n      break;\n  }\n  \n  return {\n    ...error,\n    isRetryable,\n    isTemporary,\n    suggestedAction\n  };\n}\n\n// Utility functions\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Health check utilities\nexport interface HealthStatus {\n  service: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime?: number;\n  lastCheck: string;\n  circuitState?: CircuitState;\n  details?: string;\n}\n\nexport async function checkServiceHealth(\n  serviceName: string,\n  healthCheck: () => Promise<boolean>,\n  circuitBreaker?: CircuitBreaker\n): Promise<HealthStatus> {\n  const startTime = Date.now();\n  \n  try {\n    const isHealthy = await Promise.race([\n      healthCheck(),\n      new Promise<boolean>((_, reject) => \n        setTimeout(() => reject(new Error('Health check timeout')), 5000)\n      )\n    ]);\n    \n    const responseTime = Date.now() - startTime;\n    \n    return {\n      service: serviceName,\n      status: isHealthy ? 'healthy' : 'unhealthy',\n      responseTime,\n      lastCheck: new Date().toISOString(),\n      circuitState: circuitBreaker?.getState().state,\n      details: isHealthy ? 'Service responding normally' : 'Service check failed'\n    };\n  } catch (error: any) {\n    const responseTime = Date.now() - startTime;\n    \n    return {\n      service: serviceName,\n      status: 'unhealthy',\n      responseTime,\n      lastCheck: new Date().toISOString(),\n      circuitState: circuitBreaker?.getState().state,\n      details: error.message || 'Health check failed'\n    };\n  }\n}\n","// Telemetry provider implementations\n\nimport { TelemetryLogger, TelemetryData } from '../types/api';\n\n// Console-based telemetry for both Express and Vercel\nexport class ConsoleTelemetryLogger implements TelemetryLogger {\n  log(data: TelemetryData): void {\n    // Log to stdout as JSON for easy parsing\n    console.log(JSON.stringify(data));\n  }\n}\n\n// Ring buffer telemetry for Express (enables /metrics endpoint)\nexport class RingBufferTelemetryLogger implements TelemetryLogger {\n  private buffer: TelemetryData[] = [];\n  private maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  log(data: TelemetryData): void {\n    // Add to ring buffer\n    this.buffer.push(data);\n    if (this.buffer.length > this.maxSize) {\n      this.buffer.shift();\n    }\n\n    // Also log to console\n    console.log(JSON.stringify(data));\n  }\n\n  getRecentEntries(count: number = 100): TelemetryData[] {\n    return this.buffer.slice(-count);\n  }\n\n  getMetrics(): {\n    total_calls: number;\n    success_rate: number;\n    avg_latency_ms: number;\n    p95_latency_ms: number;\n    error_breakdown: Record<string, number>;\n  } {\n    if (this.buffer.length === 0) {\n      return {\n        total_calls: 0,\n        success_rate: 0,\n        avg_latency_ms: 0,\n        p95_latency_ms: 0,\n        error_breakdown: {}\n      };\n    }\n\n    const totalCalls = this.buffer.length;\n    const successfulCalls = this.buffer.filter(entry => entry.ok).length;\n    const successRate = successfulCalls / totalCalls;\n\n    const latencies = this.buffer.map(entry => entry.total_ms).sort((a, b) => a - b);\n    const avgLatency = latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length;\n    const p95Index = Math.floor(latencies.length * 0.95);\n    const p95Latency = latencies[p95Index] || 0;\n\n    const errorBreakdown: Record<string, number> = {};\n    this.buffer\n      .filter(entry => !entry.ok && entry.err_code)\n      .forEach(entry => {\n        const errCode = entry.err_code!;\n        errorBreakdown[errCode] = (errorBreakdown[errCode] || 0) + 1;\n      });\n\n    return {\n      total_calls: totalCalls,\n      success_rate: successRate,\n      avg_latency_ms: avgLatency,\n      p95_latency_ms: p95Latency,\n      error_breakdown: errorBreakdown\n    };\n  }\n}\n","// ImageStore implementations for different environments\n\nimport { ImageStore } from '../types/api';\n\n// In-memory implementation for Express server\nexport class MemoryImageStore implements ImageStore {\n  private cache = new Map<string, { buffer: Uint8Array; expires: number }>();\n  private cleanupInterval: NodeJS.Timeout;\n\n  constructor() {\n    // Cleanup expired entries every minute\n    this.cleanupInterval = setInterval(() => {\n      const now = Date.now();\n      for (const [token, entry] of this.cache.entries()) {\n        if (entry.expires < now) {\n          this.cache.delete(token);\n        }\n      }\n    }, 60000);\n  }\n\n  async save(buffer: Uint8Array, ttlMinutes: number = 5): Promise<string> {\n    const token = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const expires = Date.now() + (ttlMinutes * 60 * 1000);\n    \n    this.cache.set(token, { buffer, expires });\n    return token;\n  }\n\n  async get(token: string): Promise<Uint8Array | null> {\n    const entry = this.cache.get(token);\n    if (!entry) return null;\n    \n    if (entry.expires < Date.now()) {\n      this.cache.delete(token);\n      return null;\n    }\n    \n    return entry.buffer;\n  }\n\n  destroy(): void {\n    clearInterval(this.cleanupInterval);\n    this.cache.clear();\n  }\n}\n\n// Global cache implementation for Vercel (best-effort)\nexport class GlobalImageStore implements ImageStore {\n  private static cache = new Map<string, { buffer: Uint8Array; expires: number }>();\n\n  async save(buffer: Uint8Array, ttlMinutes: number = 5): Promise<string> {\n    const token = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const expires = Date.now() + (ttlMinutes * 60 * 1000);\n    \n    // Best-effort global cache (may not persist across cold starts)\n    GlobalImageStore.cache.set(token, { buffer, expires });\n    return token;\n  }\n\n  async get(token: string): Promise<Uint8Array | null> {\n    const entry = GlobalImageStore.cache.get(token);\n    if (!entry) return null;\n    \n    if (entry.expires < Date.now()) {\n      GlobalImageStore.cache.delete(token);\n      return null;\n    }\n    \n    return entry.buffer;\n  }\n}\n\n// Vercel Blob implementation (for production)\nexport class VercelBlobImageStore implements ImageStore {\n  constructor(private blobToken: string) {}\n\n  async save(buffer: Uint8Array, ttlMinutes: number = 5): Promise<string> {\n    // TODO: Implement Vercel Blob storage\n    // For now, fall back to global cache\n    const fallback = new GlobalImageStore();\n    return fallback.save(buffer, ttlMinutes);\n  }\n\n  async get(token: string): Promise<Uint8Array | null> {\n    // TODO: Implement Vercel Blob retrieval\n    // For now, fall back to global cache\n    const fallback = new GlobalImageStore();\n    return fallback.get(token);\n  }\n}\n"],"mappings":"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","names":["responseTime"]}